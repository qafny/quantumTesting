{
  "circuit_name": "cdkm_ripple_carry_adder_CDKMRippleCarryAdder",
  "class_name": "CDKMRippleCarryAdder",
  "module": "qiskit.circuit.library.arithmetic.adders.cdkm_ripple_carry_adder",
  "description": "A ripple-carry circuit to perform in-place addition on two qubit registers.\n\n    As an example, a ripple-carry adder circuit that performs addition on two 3-qubit sized\n    registers with a carry-in bit (``kind=\"full\"``) is as follows:\n\n    .. code-block:: text\n\n                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         cin_0: \u25242     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25242     \u251c\n                \u2502      \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502      \u2502\n           a_0: \u25240     \u251c\u25242     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25242     \u251c\u25240     \u251c\n                \u2502      \u2502\u2502      \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502      \u2502\u2502      \u2502\n           a_1: \u2524  MAJ \u251c\u25240     \u251c\u25242     \u251c\u2500\u2500\u2500\u2500\u2500\u25242     \u251c\u25240     \u251c\u2524  UMA \u251c\n                \u2502      \u2502\u2502      \u2502\u2502      \u2502     \u2502      \u2502\u2502      \u2502\u2502      \u2502\n           a_2: \u2524      \u251c\u2524  MAJ \u251c\u25240     \u251c\u2500\u2500\u25a0\u2500\u2500\u25240     \u251c\u2524  UMA \u251c\u2524      \u251c\n                \u2502      \u2502\u2502      \u2502\u2502      \u2502  \u2502  \u2502      \u2502\u2502      \u2502\u2502      \u2502\n           b_0: \u25241     \u251c\u2524      \u251c\u2524  MAJ \u251c\u2500\u2500\u253c\u2500\u2500\u2524  UMA \u251c\u2524      \u251c\u25241     \u251c\n                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502      \u2502\u2502      \u2502  \u2502  \u2502      \u2502\u2502      \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           b_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25241     \u251c\u2524      \u251c\u2500\u2500\u253c\u2500\u2500\u2524      \u251c\u25241     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502      \u2502  \u2502  \u2502      \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           b_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25241     \u251c\u2500\u2500\u253c\u2500\u2500\u25241     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        cout_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                                        \u2514\u2500\u2500\u2500\u2518\n\n    Here *MAJ* and *UMA* gates correspond to the gates introduced in [1]. Note that\n    in this implementation the input register qubits are ordered as all qubits from\n    the first input register, followed by all qubits from the second input register.\n\n    Two different kinds of adders are supported. By setting the ``kind`` argument, you can also\n    choose a half-adder, which doesn't have a carry-in, and a fixed-sized-adder, which has neither\n    carry-in nor carry-out, and thus acts on fixed register sizes. Unlike the full-adder,\n    these circuits need one additional helper qubit.\n\n    The circuit diagram for the fixed-point adder (``kind=\"fixed\"``) on 3-qubit sized inputs is\n\n    .. code-block:: text\n\n                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n           a_0: \u25240     \u251c\u25242     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25242     \u251c\u25240     \u251c\n                \u2502      \u2502\u2502      \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502      \u2502\u2502      \u2502\n           a_1: \u2524      \u251c\u25240     \u251c\u25242     \u251c\u25242     \u251c\u25240     \u251c\u2524      \u251c\n                \u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\n           a_2: \u2524      \u251c\u2524  MAJ \u251c\u25240     \u251c\u25240     \u251c\u2524  UMA \u251c\u2524      \u251c\n                \u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\n           b_0: \u25241 MAJ \u251c\u2524      \u251c\u2524  MAJ \u251c\u2524  UMA \u251c\u2524      \u251c\u25241 UMA \u251c\n                \u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\n           b_1: \u2524      \u251c\u25241     \u251c\u2524      \u251c\u2524      \u251c\u25241     \u251c\u2524      \u251c\n                \u2502      \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502      \u2502\u2502      \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502      \u2502\n           b_2: \u2524      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25241     \u251c\u25241     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524      \u251c\n                \u2502      \u2502        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502      \u2502\n        help_0: \u25242     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25242     \u251c\n                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    It has one less qubit than the full-adder since it doesn't have the carry-out, but uses\n    a helper qubit instead of the carry-in, so it only has one less qubit, not two.\n\n    .. seealso::\n\n        The following generic gate objects perform additions, like this circuit class,\n        but allow the compiler to select the optimal decomposition based on the context.\n        Specific implementations can be set via the :class:`.HLSConfig`, e.g. this circuit\n        can be chosen via ``Adder=[\"ripple_c04\"]``.\n\n        :class:`.ModularAdderGate`: A generic inplace adder, modulo :math:`2^n`. This\n            is functionally equivalent to ``kind=\"fixed\"``.\n\n        :class:`.AdderGate`: A generic inplace adder. This\n            is functionally equivalent to ``kind=\"half\"``.\n\n        :class:`.FullAdderGate`: A generic inplace adder, with a carry-in bit. This\n            is functionally equivalent to ``kind=\"full\"``.\n\n    References:\n\n    [1] Cuccaro et al., A new quantum ripple-carry addition circuit, 2004.\n    `arXiv:quant-ph/0410184 <https://arxiv.org/pdf/quant-ph/0410184.pdf>`_\n\n    [2] Vedral et al., Quantum Networks for Elementary Arithmetic Operations, 1995.\n    `arXiv:quant-ph/9511018 <https://arxiv.org/pdf/quant-ph/9511018.pdf>`_\n\n    ",
  "num_qubits": 8,
  "num_clbits": 0,
  "specification": "\nCircuit: cdkm_ripple_carry_adder_CDKMRippleCarryAdder\nQubits: 8\nClassical bits: 0\nDepth: 1\nSize: 1\n\nExpected Behavior:\n- Circuit should compile to XMLProgrammer AST without errors\n- AST should be valid according to SimulatorValidator\n- Simulator should execute without runtime errors\n- Output state should be consistent with circuit semantics\n",
  "expected_behavior": "Circuit-specific quantum operation"
}