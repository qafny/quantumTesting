[
  {
    "class_name": "ANDGate",
    "module": "qiskit.circuit.library.boolean_logic.quantum_and",
    "doc": "A circuit implementing the logical AND operation on a number of qubits.\n\n    For the AND operation the state :math:`|1\\rangle` is interpreted as ``True``. The result\n    qubit is flipped, if the state of all variable qubits is ``True``. In this format, the AND\n    operation equals a multi-controlled X gate, which is controlled on all variable qubits.\n    Using a list of flags however, qubits can be skipped or negated. Practically, the flags\n    allow to skip controls or to apply pre- and post-X gates to the negated qubits.\n\n    The AND gate without special flags equals the multi-controlled-X gate:\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import AND\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       circuit = AND(5)\n       _generate_circuit_library_visualization(circuit)\n\n    Using flags we can negate qubits or skip them. For instance, if we have 5 qubits and want to\n    return ``True`` if the first qubit is ``False`` and the last two are ``True`` we use the flags\n    ``[-1, 0, 0, 1, 1]``.\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import AND\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       circuit = AND(5, flags=[-1, 0, 0, 1, 1])\n       _generate_circuit_library_visualization(circuit)\n\n    ",
    "parameters": {
      "num_variable_qubits": {
        "default": null,
        "annotation": "int"
      },
      "flags": {
        "default": null,
        "annotation": "list[int] | None"
      },
      "mcx_mode": {
        "default": "noancilla",
        "annotation": "str"
      }
    }
  },
  {
    "class_name": "BlueprintCircuit",
    "module": "qiskit.circuit.library.blueprintcircuit",
    "doc": "Blueprint circuit object.\n\n    In many applications it is necessary to pass around the structure a circuit will have without\n    explicitly knowing e.g. its number of qubits, or other missing information. This can be solved\n    by having a circuit that knows how to construct itself, once all information is available.\n\n    This class provides an interface for such circuits. Before internal data of the circuit is\n    accessed, the ``_build`` method is called. There the configuration of the circuit is checked.\n    ",
    "parameters": {
      "regs": {
        "default": null,
        "annotation": null
      },
      "name": {
        "default": null,
        "annotation": "str | None"
      }
    }
  },
  {
    "class_name": "CDKMRippleCarryAdder",
    "module": "qiskit.circuit.library.arithmetic.adders.cdkm_ripple_carry_adder",
    "doc": "A ripple-carry circuit to perform in-place addition on two qubit registers.\n\n    As an example, a ripple-carry adder circuit that performs addition on two 3-qubit sized\n    registers with a carry-in bit (``kind=\"full\"``) is as follows:\n\n    .. code-block:: text\n\n                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         cin_0: \u25242     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25242     \u251c\n                \u2502      \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502      \u2502\n           a_0: \u25240     \u251c\u25242     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25242     \u251c\u25240     \u251c\n                \u2502      \u2502\u2502      \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502      \u2502\u2502      \u2502\n           a_1: \u2524  MAJ \u251c\u25240     \u251c\u25242     \u251c\u2500\u2500\u2500\u2500\u2500\u25242     \u251c\u25240     \u251c\u2524  UMA \u251c\n                \u2502      \u2502\u2502      \u2502\u2502      \u2502     \u2502      \u2502\u2502      \u2502\u2502      \u2502\n           a_2: \u2524      \u251c\u2524  MAJ \u251c\u25240     \u251c\u2500\u2500\u25a0\u2500\u2500\u25240     \u251c\u2524  UMA \u251c\u2524      \u251c\n                \u2502      \u2502\u2502      \u2502\u2502      \u2502  \u2502  \u2502      \u2502\u2502      \u2502\u2502      \u2502\n           b_0: \u25241     \u251c\u2524      \u251c\u2524  MAJ \u251c\u2500\u2500\u253c\u2500\u2500\u2524  UMA \u251c\u2524      \u251c\u25241     \u251c\n                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502      \u2502\u2502      \u2502  \u2502  \u2502      \u2502\u2502      \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           b_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25241     \u251c\u2524      \u251c\u2500\u2500\u253c\u2500\u2500\u2524      \u251c\u25241     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502      \u2502  \u2502  \u2502      \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           b_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25241     \u251c\u2500\u2500\u253c\u2500\u2500\u25241     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        cout_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                                        \u2514\u2500\u2500\u2500\u2518\n\n    Here *MAJ* and *UMA* gates correspond to the gates introduced in [1]. Note that\n    in this implementation the input register qubits are ordered as all qubits from\n    the first input register, followed by all qubits from the second input register.\n\n    Two different kinds of adders are supported. By setting the ``kind`` argument, you can also\n    choose a half-adder, which doesn't have a carry-in, and a fixed-sized-adder, which has neither\n    carry-in nor carry-out, and thus acts on fixed register sizes. Unlike the full-adder,\n    these circuits need one additional helper qubit.\n\n    The circuit diagram for the fixed-point adder (``kind=\"fixed\"``) on 3-qubit sized inputs is\n\n    .. code-block:: text\n\n                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n           a_0: \u25240     \u251c\u25242     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25242     \u251c\u25240     \u251c\n                \u2502      \u2502\u2502      \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502      \u2502\u2502      \u2502\n           a_1: \u2524      \u251c\u25240     \u251c\u25242     \u251c\u25242     \u251c\u25240     \u251c\u2524      \u251c\n                \u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\n           a_2: \u2524      \u251c\u2524  MAJ \u251c\u25240     \u251c\u25240     \u251c\u2524  UMA \u251c\u2524      \u251c\n                \u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\n           b_0: \u25241 MAJ \u251c\u2524      \u251c\u2524  MAJ \u251c\u2524  UMA \u251c\u2524      \u251c\u25241 UMA \u251c\n                \u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\n           b_1: \u2524      \u251c\u25241     \u251c\u2524      \u251c\u2524      \u251c\u25241     \u251c\u2524      \u251c\n                \u2502      \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502      \u2502\u2502      \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502      \u2502\n           b_2: \u2524      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25241     \u251c\u25241     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524      \u251c\n                \u2502      \u2502        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502      \u2502\n        help_0: \u25242     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25242     \u251c\n                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    It has one less qubit than the full-adder since it doesn't have the carry-out, but uses\n    a helper qubit instead of the carry-in, so it only has one less qubit, not two.\n\n    .. seealso::\n\n        The following generic gate objects perform additions, like this circuit class,\n        but allow the compiler to select the optimal decomposition based on the context.\n        Specific implementations can be set via the :class:`.HLSConfig`, e.g. this circuit\n        can be chosen via ``Adder=[\"ripple_c04\"]``.\n\n        :class:`.ModularAdderGate`: A generic inplace adder, modulo :math:`2^n`. This\n            is functionally equivalent to ``kind=\"fixed\"``.\n\n        :class:`.AdderGate`: A generic inplace adder. This\n            is functionally equivalent to ``kind=\"half\"``.\n\n        :class:`.FullAdderGate`: A generic inplace adder, with a carry-in bit. This\n            is functionally equivalent to ``kind=\"full\"``.\n\n    References:\n\n    [1] Cuccaro et al., A new quantum ripple-carry addition circuit, 2004.\n    `arXiv:quant-ph/0410184 <https://arxiv.org/pdf/quant-ph/0410184.pdf>`_\n\n    [2] Vedral et al., Quantum Networks for Elementary Arithmetic Operations, 1995.\n    `arXiv:quant-ph/9511018 <https://arxiv.org/pdf/quant-ph/9511018.pdf>`_\n\n    ",
    "parameters": {
      "num_state_qubits": {
        "default": null,
        "annotation": "<class 'int'>"
      },
      "kind": {
        "default": "full",
        "annotation": "<class 'str'>"
      },
      "name": {
        "default": "CDKMRippleCarryAdder",
        "annotation": "<class 'str'>"
      }
    }
  },
  {
    "class_name": "DiagonalGate",
    "module": "qiskit.circuit.library.generalized_gates.diagonal",
    "doc": "Circuit implementing a diagonal transformation.",
    "parameters": {
      "diag": {
        "default": null,
        "annotation": "Sequence[complex]"
      }
    }
  },
  {
    "class_name": "DraperQFTAdder",
    "module": "qiskit.circuit.library.arithmetic.adders.draper_qft_adder",
    "doc": "A circuit that uses QFT to perform in-place addition on two qubit registers.\n\n    For registers with :math:`n` qubits, the QFT adder can perform addition modulo\n    :math:`2^n` (with ``kind=\"fixed\"``) or ordinary addition by adding a carry qubits (with\n    ``kind=\"half\"``).\n\n    As an example, a non-fixed_point QFT adder circuit that performs addition on two 2-qubit sized\n    registers is as follows:\n\n    .. code-block:: text\n\n         a_0:   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                         \u2502      \u2502                        \u2502\n         a_1:   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502P(\u03c0)  \u2502        \u2502      \u2502        \u2502       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         b_0:   \u25240     \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25240      \u251c\n                \u2502      \u2502        \u2502P(\u03c0/2)  \u2502P(\u03c0)  \u2502        \u2502       \u2502       \u2502\n         b_1:   \u25241 qft \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25241 iqft \u251c\n                \u2502      \u2502                        \u2502P(\u03c0/2)  \u2502P(\u03c0/4) \u2502       \u2502\n        cout_0: \u25242     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25242      \u251c\n                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    .. seealso::\n\n        The following generic gate objects perform additions, like this circuit class,\n        but allow the compiler to select the optimal decomposition based on the context.\n        Specific implementations can be set via the :class:`.HLSConfig`, e.g. this\n        circuit can be chosen via ``Adder=[\"qft_d00\"]``.\n\n        :class:`.ModularAdderGate`: A generic inplace adder, modulo :math:`2^n`. This\n            is functionally equivalent to ``kind=\"fixed\"``.\n\n        :class:`.AdderGate`: A generic inplace adder. This\n            is functionally equivalent to ``kind=\"half\"``.\n\n    References:\n\n    [1] T. G. Draper, Addition on a Quantum Computer, 2000.\n    `arXiv:quant-ph/0008033 <https://arxiv.org/pdf/quant-ph/0008033.pdf>`_\n\n    [2] Ruiz-Perez et al., Quantum arithmetic with the Quantum Fourier Transform, 2017.\n    `arXiv:1411.5949 <https://arxiv.org/pdf/1411.5949.pdf>`_\n\n    [3] Vedral et al., Quantum Networks for Elementary Arithmetic Operations, 1995.\n    `arXiv:quant-ph/9511018 <https://arxiv.org/pdf/quant-ph/9511018.pdf>`_\n\n    ",
    "parameters": {
      "num_state_qubits": {
        "default": null,
        "annotation": "<class 'int'>"
      },
      "kind": {
        "default": "fixed",
        "annotation": "<class 'str'>"
      },
      "name": {
        "default": "DraperQFTAdder",
        "annotation": "<class 'str'>"
      }
    }
  },
  {
    "class_name": "EfficientSU2",
    "module": "qiskit.circuit.library.n_local.efficient_su2",
    "doc": "The hardware efficient SU(2) 2-local circuit.\n\n    The ``EfficientSU2`` circuit consists of layers of single qubit operations spanned by SU(2)\n    and :math:`CX` entanglements. This is a heuristic pattern that can be used to prepare trial wave\n    functions for variational quantum algorithms or classification circuit for machine learning.\n\n    SU(2) stands for special unitary group of degree 2, its elements are :math:`2 \\times 2`\n    unitary matrices with determinant 1, such as the Pauli rotation gates.\n\n    On 3 qubits and using the Pauli :math:`Y` and :math:`Z` su2_gates as single qubit gates, the\n    hardware efficient SU(2) circuit is represented by:\n\n    .. code-block:: text\n\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591            \u2591       \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2524 RY(\u03b8[0]) \u251c\u2524 RZ(\u03b8[3]) \u251c\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2591\u2500 ... \u2500\u2591\u2500\u2524 RY(\u03b8[12]) \u251c\u2524 RZ(\u03b8[15]) \u251c\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591      \u250c\u2500\u2534\u2500\u2510 \u2591       \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2524 RY(\u03b8[1]) \u251c\u2524 RZ(\u03b8[4]) \u251c\u2500\u2591\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2591\u2500 ... \u2500\u2591\u2500\u2524 RY(\u03b8[13]) \u251c\u2524 RZ(\u03b8[16]) \u251c\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518 \u2591       \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2524 RY(\u03b8[2]) \u251c\u2524 RZ(\u03b8[5]) \u251c\u2500\u2591\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500 ... \u2500\u2591\u2500\u2524 RY(\u03b8[14]) \u251c\u2524 RZ(\u03b8[17]) \u251c\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2518      \u2591       \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    See :class:`~qiskit.circuit.library.RealAmplitudes` for more detail on the possible arguments\n    and options such as skipping unentanglement qubits, which apply here too.\n\n    Examples:\n\n        >>> circuit = EfficientSU2(3, reps=1)\n        >>> print(circuit.decompose())\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 RY(\u03b8[0]) \u251c\u2524 RZ(\u03b8[3]) \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 RY(\u03b8[6]) \u251c\u2524 RZ(\u03b8[9]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u250c\u2500\u2534\u2500\u2510  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_1: \u2524 RY(\u03b8[1]) \u251c\u2524 RZ(\u03b8[4]) \u251c\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 RY(\u03b8[7]) \u251c\u2524 RZ(\u03b8[10]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510   \u250c\u2500\u2534\u2500\u2510    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_2: \u2524 RY(\u03b8[2]) \u251c\u2524 RZ(\u03b8[5]) \u251c\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2524 RY(\u03b8[8]) \u251c\u2524 RZ(\u03b8[11]) \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> ansatz = EfficientSU2(4, su2_gates=['rx', 'y'], entanglement='circular', reps=1,\n        ... flatten=True)\n        >>> qc = QuantumCircuit(4)  # create a circuit and append the RY variational form\n        >>> qc.compose(ansatz, inplace=True)\n        >>> qc.draw()\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510\n        q_0: \u2524 RX(\u03b8[0]) \u251c\u2524 Y \u251c\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2524 RX(\u03b8[4]) \u251c\u2500\u2500\u2500\u2524 Y \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2524\u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510\n        q_1: \u2524 RX(\u03b8[1]) \u251c\u2524 Y \u251c\u2500\u2500\u253c\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 RX(\u03b8[5]) \u251c\u2500\u2500\u2500\u2524 Y \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2524  \u2502  \u2514\u2500\u2500\u2500\u2518   \u250c\u2500\u2534\u2500\u2510    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\n        q_2: \u2524 RX(\u03b8[2]) \u251c\u2524 Y \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 RX(\u03b8[6]) \u251c\u2524 Y \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2524  \u2502          \u2514\u2500\u2500\u2500\u2518       \u250c\u2500\u2534\u2500\u2510    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2524\n        q_3: \u2524 RX(\u03b8[3]) \u251c\u2524 Y \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2524 RX(\u03b8[7]) \u251c\u2524 Y \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518                         \u2514\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\n\n    .. seealso::\n\n        The :func:`.efficient_su2` function constructs a functionally equivalent circuit, but faster.\n\n    ",
    "parameters": {
      "num_qubits": {
        "default": null,
        "annotation": "int | None"
      },
      "su2_gates": {
        "default": null,
        "annotation": "str | type | qiskit.circuit.Instruction | QuantumCircuit | list[str | type | qiskit.circuit.Instruction | QuantumCircuit] | None"
      },
      "entanglement": {
        "default": "reverse_linear",
        "annotation": "str | list[list[int]] | Callable[[int], list[int]]"
      },
      "reps": {
        "default": 3,
        "annotation": "int"
      },
      "skip_unentangled_qubits": {
        "default": false,
        "annotation": "bool"
      },
      "skip_final_rotation_layer": {
        "default": false,
        "annotation": "bool"
      },
      "parameter_prefix": {
        "default": "\u03b8",
        "annotation": "str"
      },
      "insert_barriers": {
        "default": false,
        "annotation": "bool"
      },
      "initial_state": {
        "default": null,
        "annotation": "QuantumCircuit | None"
      },
      "name": {
        "default": "EfficientSU2",
        "annotation": "str"
      },
      "flatten": {
        "default": null,
        "annotation": "bool | None"
      }
    }
  },
  {
    "class_name": "EvolvedOperatorAnsatz",
    "module": "qiskit.circuit.library.n_local.evolved_operator_ansatz",
    "doc": "The evolved operator ansatz.",
    "parameters": {
      "operators": {
        "default": null,
        "annotation": null
      },
      "reps": {
        "default": 1,
        "annotation": "int"
      },
      "evolution": {
        "default": null,
        "annotation": null
      },
      "insert_barriers": {
        "default": false,
        "annotation": "bool"
      },
      "name": {
        "default": "EvolvedOps",
        "annotation": "str"
      },
      "parameter_prefix": {
        "default": "t",
        "annotation": "str | Sequence[str]"
      },
      "initial_state": {
        "default": null,
        "annotation": "QuantumCircuit | None"
      },
      "flatten": {
        "default": null,
        "annotation": "bool | None"
      }
    }
  },
  {
    "class_name": "ExactReciprocalGate",
    "module": "qiskit.circuit.library.arithmetic.exact_reciprocal",
    "doc": "Exact reciprocal\n\n    .. math::\n\n        |x\\rangle |0\\rangle \\mapsto \\cos(1/x)|x\\rangle|0\\rangle + \\sin(1/x)|x\\rangle |1\\rangle\n    ",
    "parameters": {
      "num_state_qubits": {
        "default": null,
        "annotation": "<class 'int'>"
      },
      "scaling": {
        "default": null,
        "annotation": "<class 'float'>"
      },
      "neg_vals": {
        "default": false,
        "annotation": "<class 'bool'>"
      },
      "name": {
        "default": "1/x",
        "annotation": "<class 'str'>"
      }
    }
  },
  {
    "class_name": "ExcitationPreserving",
    "module": "qiskit.circuit.library.n_local.excitation_preserving",
    "doc": "The heuristic excitation-preserving wave function ansatz.\n\n    The ``ExcitationPreserving`` circuit preserves the ratio of :math:`|00\\rangle`,\n    :math:`|01\\rangle + |10\\rangle` and :math:`|11\\rangle` states. To this end, this circuit\n    uses two-qubit interactions of the form\n\n    .. math::\n\n        \\newcommand{\\rotationangle}{\\theta/2}\n\n        \\begin{pmatrix}\n        1 & 0 & 0 & 0 \\\\\n        0 & \\cos\\left(\\rotationangle\\right) & -i\\sin\\left(\\rotationangle\\right) & 0 \\\\\n        0 & -i\\sin\\left(\\rotationangle\\right) & \\cos\\left(\\rotationangle\\right) & 0 \\\\\n        0 & 0 & 0 & e^{-i\\phi}\n        \\end{pmatrix}\n\n    for the mode ``'fsim'`` or with :math:`e^{-i\\phi} = 1` for the mode ``'iswap'``.\n\n    Note that other wave functions, such as UCC-ansatzes, are also excitation preserving.\n    However these can become complex quickly, while this heuristically motivated circuit follows\n    a simpler pattern.\n\n    This trial wave function consists of layers of :math:`Z` rotations with 2-qubit entanglements.\n    The entangling is creating using :math:`XX+YY` rotations and optionally a controlled-phase\n    gate for the mode ``'fsim'``.\n\n    See :class:`~qiskit.circuit.library.RealAmplitudes` for more detail on the possible arguments\n    and options such as skipping unentanglement qubits, which apply here too.\n\n    The rotations of the ExcitationPreserving ansatz can be written as\n\n    Examples:\n\n        >>> ansatz = ExcitationPreserving(3, reps=1, insert_barriers=True, entanglement='linear')\n        >>> print(ansatz.decompose())  # show the circuit\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 RZ(\u03b8[0]) \u251c\u2500\u2591\u2500\u25240           \u251c\u25240           \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 RZ(\u03b8[5]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u2502  RXX(\u03b8[3]) \u2502\u2502  RYY(\u03b8[3]) \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_1: \u2524 RZ(\u03b8[1]) \u251c\u2500\u2591\u2500\u25241           \u251c\u25241           \u251c\u25240           \u251c\u25240           \u251c\u2500\u2591\u2500\u2524 RZ(\u03b8[6]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502  RXX(\u03b8[4]) \u2502\u2502  RYY(\u03b8[4]) \u2502 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_2: \u2524 RZ(\u03b8[2]) \u251c\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25241           \u251c\u25241           \u251c\u2500\u2591\u2500\u2524 RZ(\u03b8[7]) \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> ansatz = ExcitationPreserving(2, reps=1, flatten=True)\n        >>> qc = QuantumCircuit(2)  # create a circuit and append the RY variational form\n        >>> qc.cry(0.2, 0, 1)  # do some previous operation\n        >>> qc.compose(ansatz, inplace=True)  # add the excitation-preserving\n        >>> qc.draw()\n                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2524 RZ(\u03b8[0]) \u251c\u25240           \u251c\u25240           \u251c\u2524 RZ(\u03b8[3]) \u251c\n             \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2502  RXX(\u03b8[2]) \u2502\u2502  RYY(\u03b8[2]) \u2502\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_1: \u2524 RY(0.2) \u251c\u2524 RZ(\u03b8[1]) \u251c\u25241           \u251c\u25241           \u251c\u2524 RZ(\u03b8[4]) \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> ansatz = ExcitationPreserving(3, reps=1, mode='fsim', entanglement=[[0,2]],\n        ... insert_barriers=True, flatten=True)\n        >>> print(ansatz.decompose())\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 RZ(\u03b8[0]) \u251c\u2500\u2591\u2500\u25240           \u251c\u25240           \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 RZ(\u03b8[5]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u2502            \u2502\u2502            \u2502 \u2502      \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_1: \u2524 RZ(\u03b8[1]) \u251c\u2500\u2591\u2500\u2524  RXX(\u03b8[3]) \u251c\u2524  RYY(\u03b8[3]) \u251c\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 RZ(\u03b8[6]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u2502            \u2502\u2502            \u2502 \u2502\u03b8[4]  \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_2: \u2524 RZ(\u03b8[2]) \u251c\u2500\u2591\u2500\u25241           \u251c\u25241           \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 RZ(\u03b8[7]) \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    .. seealso::\n\n        The :func:`.excitation_preserving` function constructs a functionally equivalent circuit,\n        but faster.\n\n    ",
    "parameters": {
      "num_qubits": {
        "default": null,
        "annotation": "int | None"
      },
      "mode": {
        "default": "iswap",
        "annotation": "str"
      },
      "entanglement": {
        "default": "full",
        "annotation": "str | list[list[int]] | Callable[[int], list[int]]"
      },
      "reps": {
        "default": 3,
        "annotation": "int"
      },
      "skip_unentangled_qubits": {
        "default": false,
        "annotation": "bool"
      },
      "skip_final_rotation_layer": {
        "default": false,
        "annotation": "bool"
      },
      "parameter_prefix": {
        "default": "\u03b8",
        "annotation": "str"
      },
      "insert_barriers": {
        "default": false,
        "annotation": "bool"
      },
      "initial_state": {
        "default": null,
        "annotation": "QuantumCircuit | None"
      },
      "name": {
        "default": "ExcitationPreserving",
        "annotation": "str"
      },
      "flatten": {
        "default": null,
        "annotation": "bool | None"
      }
    }
  },
  {
    "class_name": "FourierChecking",
    "module": "qiskit.circuit.library.fourier_checking",
    "doc": "Fourier checking circuit.\n\n    The circuit for the Fourier checking algorithm, introduced in [1],\n    involves a layer of Hadamards, the function :math:`f`, another layer of\n    Hadamards, the function :math:`g`, followed by a final layer of Hadamards.\n    The functions :math:`f` and :math:`g` are classical functions realized\n    as phase oracles (diagonal operators with {-1, 1} on the diagonal).\n\n    The probability of observing the all-zeros string is :math:`p(f,g)`.\n    The algorithm solves the promise Fourier checking problem,\n    which decides if f is correlated with the Fourier transform\n    of g, by testing if :math:`p(f,g) <= 0.01` or :math:`p(f,g) >= 0.05`,\n    promised that one or the other of these is true.\n\n    The functions :math:`f` and :math:`g` are currently implemented\n    from their truth tables but could be represented concisely and\n    implemented efficiently for special classes of functions.\n\n    Fourier checking is a special case of :math:`k`-fold forrelation [2].\n\n    References:\n\n    [1] S. Aaronson, BQP and the Polynomial Hierarchy, 2009 (Section 3.2).\n    `arXiv:0910.4698 <https://arxiv.org/abs/0910.4698>`_\n\n    [2] S. Aaronson, A. Ambainis, Forrelation: a problem that\n    optimally separates quantum from classical computing, 2014.\n    `arXiv:1411.5729 <https://arxiv.org/abs/1411.5729>`_\n    ",
    "parameters": {
      "f": {
        "default": null,
        "annotation": "collections.abc.Sequence[int]"
      },
      "g": {
        "default": null,
        "annotation": "collections.abc.Sequence[int]"
      }
    }
  },
  {
    "class_name": "FunctionalPauliRotations",
    "module": "qiskit.circuit.library.arithmetic.functional_pauli_rotations",
    "doc": "Base class for functional Pauli rotations.",
    "parameters": {
      "num_state_qubits": {
        "default": null,
        "annotation": "typing.Optional[int]"
      },
      "basis": {
        "default": "Y",
        "annotation": "<class 'str'>"
      },
      "name": {
        "default": "F",
        "annotation": "<class 'str'>"
      }
    }
  },
  {
    "class_name": "MSGate",
    "module": "qiskit.circuit.library.generalized_gates.gms",
    "doc": "Global M\u00f8lmer\u2013S\u00f8rensen gate.\n\n    Circuit symbol:\n\n    .. code-block:: text\n\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u25240          \u251c\n             \u2502           \u2502\n        q_1: \u25241   GMS    \u251c\n             \u2502           \u2502\n        q_2: \u25242          \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Expanded Circuit:\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import GMS\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       import numpy as np\n       circuit = GMS(num_qubits=3, theta=[[0, np.pi/4, np.pi/8],\n                                          [0, 0, np.pi/2],\n                                          [0, 0, 0]])\n       _generate_circuit_library_visualization(circuit.decompose())\n\n    The M\u00f8lmer\u2013S\u00f8rensen gate is native to ion-trap systems. The global MS\n    can be applied to multiple ions to entangle multiple qubits simultaneously [1].\n\n    In the two-qubit case, this is equivalent to an XX(theta) interaction,\n    and is thus reduced to the RXXGate. The global MS gate is a sum of XX\n    interactions on all pairs [2].\n\n    .. math::\n\n        GMS(\\chi_{12}, \\chi_{13}, ..., \\chi_{n-1 n}) =\n        exp(-i \\sum_{i=1}^{n} \\sum_{j=i+1}^{n} X{\\otimes}X \\frac{\\chi_{ij}}{2})\n\n    References:\n\n    [1] S\u00f8rensen, A. and M\u00f8lmer, K., Multi-particle entanglement of hot trapped ions.\n    Physical Review Letters. 82 (9): 1835\u20131838.\n    `arXiv:9810040 <https://arxiv.org/abs/quant-ph/9810040>`_\n\n    [2] Maslov, D. and Nam, Y., Use of global interactions in efficient quantum circuit\n    constructions. New Journal of Physics, 20(3), p.033018.\n    `arXiv:1707.06356 <https://arxiv.org/abs/1707.06356>`_\n    ",
    "parameters": {
      "num_qubits": {
        "default": null,
        "annotation": "int"
      },
      "theta": {
        "default": null,
        "annotation": "list[list[float]] | np.ndarray"
      }
    }
  },
  {
    "class_name": "GR",
    "module": "qiskit.circuit.library.generalized_gates.gr",
    "doc": "Global R gate.\n\n    Circuit symbol:\n\n    .. code-block:: text\n\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u25240         \u251c\n             \u2502          \u2502\n        q_1: \u25241 GR(\u03f4,\u03c6) \u251c\n             \u2502          \u2502\n        q_2: \u25242         \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    The global R gate is native to atomic systems (ion traps, cold neutrals). The global R\n    can be applied to multiple qubits simultaneously.\n\n    In the one-qubit case, this is equivalent to an R(theta, phi) operation,\n    and is thus reduced to the RGate. The global R gate is a direct sum of R\n    operations on all individual qubits.\n\n    .. math::\n\n        GR(\\theta, \\phi) = \\exp(-i \\sum_{i=1}^{n} (\\cos(\\phi)X_i + \\sin(\\phi)Y_i) \\theta/2)\n\n    Expanded Circuit:\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import GR\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       import numpy as np\n       circuit = GR(num_qubits=3, theta=np.pi/4, phi=np.pi/2)\n       _generate_circuit_library_visualization(circuit)\n\n    ",
    "parameters": {
      "num_qubits": {
        "default": null,
        "annotation": "<class 'int'>"
      },
      "theta": {
        "default": null,
        "annotation": "<class 'float'>"
      },
      "phi": {
        "default": null,
        "annotation": "<class 'float'>"
      }
    }
  },
  {
    "class_name": "GRX",
    "module": "qiskit.circuit.library.generalized_gates.gr",
    "doc": "Global RX gate.\n\n    **Circuit symbol:**\n\n    .. code-block:: text\n\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u25240         \u251c\n             \u2502          \u2502\n        q_1: \u25241  GRX(\u03f4) \u251c\n             \u2502          \u2502\n        q_2: \u25242         \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    The global RX gate is native to atomic systems (ion traps, cold neutrals). The global RX\n    can be applied to multiple qubits simultaneously.\n\n    In the one-qubit case, this is equivalent to an RX(theta) operations,\n    and is thus reduced to the RXGate. The global RX gate is a direct sum of RX\n    operations on all individual qubits.\n\n    .. math::\n\n        GRX(\\theta) = \\exp(-i \\sum_{i=1}^{n} X_i \\theta/2)\n\n    **Expanded Circuit:**\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n        from qiskit.circuit.library import GRX\n        from qiskit.visualization.library import _generate_circuit_library_visualization\n        import numpy as np\n        circuit = GRX(num_qubits=3, theta=np.pi/4)\n        _generate_circuit_library_visualization(circuit)\n\n    ",
    "parameters": {
      "num_qubits": {
        "default": null,
        "annotation": "<class 'int'>"
      },
      "theta": {
        "default": null,
        "annotation": "<class 'float'>"
      }
    }
  },
  {
    "class_name": "GRY",
    "module": "qiskit.circuit.library.generalized_gates.gr",
    "doc": "Global RY gate.\n\n    **Circuit symbol:**\n\n    .. code-block:: text\n\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u25240         \u251c\n             \u2502          \u2502\n        q_1: \u25241  GRY(\u03f4) \u251c\n             \u2502          \u2502\n        q_2: \u25242         \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    The global RY gate is native to atomic systems (ion traps, cold neutrals). The global RY\n    can be applied to multiple qubits simultaneously.\n\n    In the one-qubit case, this is equivalent to an RY(theta) operation,\n    and is thus reduced to the RYGate. The global RY gate is a direct sum of RY\n    operations on all individual qubits.\n\n    .. math::\n\n        GRY(\\theta) = \\exp(-i \\sum_{i=1}^{n} Y_i \\theta/2)\n\n    **Expanded Circuit:**\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import GRY\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       import numpy as np\n       circuit = GRY(num_qubits=3, theta=np.pi/4)\n       _generate_circuit_library_visualization(circuit)\n\n    ",
    "parameters": {
      "num_qubits": {
        "default": null,
        "annotation": "<class 'int'>"
      },
      "theta": {
        "default": null,
        "annotation": "<class 'float'>"
      }
    }
  },
  {
    "class_name": "GRZ",
    "module": "qiskit.circuit.library.generalized_gates.gr",
    "doc": "Global RZ gate.\n\n    **Circuit symbol:**\n\n    .. code-block:: text\n\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u25240         \u251c\n             \u2502          \u2502\n        q_1: \u25241  GRZ(\u03c6) \u251c\n             \u2502          \u2502\n        q_2: \u25242         \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    The global RZ gate is native to atomic systems (ion traps, cold neutrals). The global RZ\n    can be applied to multiple qubits simultaneously.\n\n    In the one-qubit case, this is equivalent to an RZ(phi) operation,\n    and is thus reduced to the RZGate. The global RZ gate is a direct sum of RZ\n    operations on all individual qubits.\n\n    .. math::\n\n        GRZ(\\phi) = \\exp(-i \\sum_{i=1}^{n} Z_i \\phi)\n\n    **Expanded Circuit:**\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import GRZ\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       import numpy as np\n       circuit = GRZ(num_qubits=3, phi=np.pi/2)\n       _generate_circuit_library_visualization(circuit)\n\n    ",
    "parameters": {
      "num_qubits": {
        "default": null,
        "annotation": "<class 'int'>"
      },
      "phi": {
        "default": null,
        "annotation": "<class 'float'>"
      }
    }
  },
  {
    "class_name": "GraphStateGate",
    "module": "qiskit.circuit.library.graph_state",
    "doc": "Circuit to prepare a graph state.\n\n    Given a graph G = (V, E), with the set of vertices V and the set of edges E,\n    the corresponding graph state is defined as\n\n    .. math::\n\n        |G\\rangle = \\prod_{(a,b) \\in E} CZ_{(a,b)} {|+\\rangle}^{\\otimes V}\n\n    Such a state can be prepared by first preparing all qubits in the :math:`+`\n    state, then applying a :math:`CZ` gate for each corresponding graph edge.\n\n    Graph state preparation circuits are Clifford circuits, and thus\n    easy to simulate classically. However, by adding a layer of measurements\n    in a product basis at the end, there is evidence that the circuit becomes\n    hard to simulate [2].\n\n    Reference Circuit:\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import GraphState\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       import rustworkx as rx\n       G = rx.generators.cycle_graph(5)\n       circuit = GraphState(rx.adjacency_matrix(G))\n       circuit.name = \"Graph state\"\n       _generate_circuit_library_visualization(circuit)\n\n    References:\n\n    [1] M. Hein, J. Eisert, H.J. Briegel, Multi-party Entanglement in Graph States,\n        `arXiv:0307130 <https://arxiv.org/pdf/quant-ph/0307130.pdf>`_\n    [2] D. Koh, Further Extensions of Clifford Circuits & their Classical Simulation Complexities.\n        `arXiv:1512.07892 <https://arxiv.org/pdf/1512.07892.pdf>`_\n    ",
    "parameters": {
      "adjacency_matrix": {
        "default": null,
        "annotation": "list | np.ndarray"
      }
    }
  },
  {
    "class_name": "GroverOperator",
    "module": "qiskit.circuit.library.grover_operator",
    "doc": "The Grover operator.\n\n    Grover's search algorithm [1, 2] consists of repeated applications of the so-called\n    Grover operator used to amplify the amplitudes of the desired output states.\n    This operator, :math:`\\mathcal{Q}`, consists of the phase oracle, :math:`\\mathcal{S}_f`,\n    zero phase-shift or zero reflection, :math:`\\mathcal{S}_0`, and an\n    input state preparation :math:`\\mathcal{A}`:\n\n    .. math::\n        \\mathcal{Q} = \\mathcal{A} \\mathcal{S}_0 \\mathcal{A}^\\dagger \\mathcal{S}_f\n\n    In the standard Grover search we have :math:`\\mathcal{A} = H^{\\otimes n}`:\n\n    .. math::\n        \\mathcal{Q} = H^{\\otimes n} \\mathcal{S}_0 H^{\\otimes n} \\mathcal{S}_f\n                    = D \\mathcal{S_f}\n\n    The operation :math:`D = H^{\\otimes n} \\mathcal{S}_0 H^{\\otimes n}` is also referred to as\n    diffusion operator. In this formulation we can see that Grover's operator consists of two\n    steps: first, the phase oracle multiplies the good states by -1 (with :math:`\\mathcal{S}_f`)\n    and then the whole state is reflected around the mean (with :math:`D`).\n\n    This class allows setting a different state preparation, as in quantum amplitude\n    amplification (a generalization of Grover's algorithm), :math:`\\mathcal{A}` might not be\n    a layer of Hardamard gates [3].\n\n    The action of the phase oracle :math:`\\mathcal{S}_f` is defined as\n\n    .. math::\n        \\mathcal{S}_f: |x\\rangle \\mapsto (-1)^{f(x)}|x\\rangle\n\n    where :math:`f(x) = 1` if :math:`x` is a good state and 0 otherwise. To highlight the fact\n    that this oracle flips the phase of the good states and does not flip the state of a result\n    qubit, we call :math:`\\mathcal{S}_f` a phase oracle.\n\n    Note that you can easily construct a phase oracle from a bitflip oracle by sandwiching the\n    controlled X gate on the result qubit by a X and H gate. For instance\n\n    .. code-block:: text\n\n        Bitflip oracle     Phaseflip oracle\n        q_0: \u2500\u2500\u25a0\u2500\u2500         q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u250c\u2500\u2534\u2500\u2510              \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\n        out: \u2524 X \u251c         out: \u2524 X \u251c\u2524 H \u251c\u2524 X \u251c\u2524 H \u251c\u2524 X \u251c\n             \u2514\u2500\u2500\u2500\u2518              \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\n\n    There is some flexibility in defining the oracle and :math:`\\mathcal{A}` operator. Before the\n    Grover operator is applied in Grover's algorithm, the qubits are first prepared with one\n    application of the :math:`\\mathcal{A}` operator (or Hadamard gates in the standard formulation).\n    Thus, we always have operation of the form\n    :math:`\\mathcal{A} \\mathcal{S}_f \\mathcal{A}^\\dagger`. Therefore it is possible to move\n    bitflip logic into :math:`\\mathcal{A}` and leaving the oracle only to do phaseflips via Z gates\n    based on the bitflips. One possible use-case for this are oracles that do not uncompute the\n    state qubits.\n\n    The zero reflection :math:`\\mathcal{S}_0` is usually defined as\n\n    .. math::\n        \\mathcal{S}_0 = 2 |0\\rangle^{\\otimes n} \\langle 0|^{\\otimes n} - \\mathbb{I}_n\n\n    where :math:`\\mathbb{I}_n` is the identity on :math:`n` qubits.\n    By default, this class implements the negative version\n    :math:`2 |0\\rangle^{\\otimes n} \\langle 0|^{\\otimes n} - \\mathbb{I}_n`, since this can simply\n    be implemented with a multi-controlled Z sandwiched by X gates on the target qubit and the\n    introduced global phase does not matter for Grover's algorithm.\n\n    Examples:\n        >>> from qiskit.circuit import QuantumCircuit\n        >>> from qiskit.circuit.library import GroverOperator\n        >>> oracle = QuantumCircuit(2)\n        >>> oracle.z(0)  # good state = first qubit is |1>\n        >>> grover_op = GroverOperator(oracle, insert_barriers=True)\n        >>> grover_op.decompose().draw()\n                 \u250c\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2510      \u2591 \u250c\u2500\u2500\u2500\u2510\n        state_0: \u2524 Z \u251c\u2500\u2591\u2500\u2524 H \u251c\u2500\u2591\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 H \u251c\n                 \u2514\u2500\u2500\u2500\u2518 \u2591 \u251c\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2524\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u251c\u2500\u2500\u2500\u2524\u250c\u2500\u2500\u2500\u2510 \u2591 \u251c\u2500\u2500\u2500\u2524\n        state_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 H \u251c\u2500\u2591\u2500\u2524 X \u251c\u2524 H \u251c\u2524 X \u251c\u2524 H \u251c\u2524 X \u251c\u2500\u2591\u2500\u2524 H \u251c\n                       \u2591 \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2518\n\n        >>> oracle = QuantumCircuit(1)\n        >>> oracle.z(0)  # the qubit state |1> is the good state\n        >>> state_preparation = QuantumCircuit(1)\n        >>> state_preparation.ry(0.2, 0)  # non-uniform state preparation\n        >>> grover_op = GroverOperator(oracle, state_preparation)\n        >>> grover_op.decompose().draw()\n                 \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        state_0: \u2524 Z \u251c\u2524 RY(-0.2) \u251c\u2524 X \u251c\u2524 Z \u251c\u2524 X \u251c\u2524 RY(0.2) \u251c\n                 \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> oracle = QuantumCircuit(4)\n        >>> oracle.z(3)\n        >>> reflection_qubits = [0, 3]\n        >>> state_preparation = QuantumCircuit(4)\n        >>> state_preparation.cry(0.1, 0, 3)\n        >>> state_preparation.ry(0.5, 3)\n        >>> grover_op = GroverOperator(oracle, state_preparation,\n        ... reflection_qubits=reflection_qubits)\n        >>> grover_op.decompose().draw()\n                                              \u250c\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2510\n        state_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                                       \u2502      \u2514\u2500\u2500\u2500\u2518       \u2502  \u2514\u2500\u2500\u2500\u2518          \u2502\n        state_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                                       \u2502                  \u2502                 \u2502\n        state_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                 \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        state_3: \u2524 Z \u251c\u2524 RY(-0.5) \u251c\u2524 RY(-0.1) \u251c\u2524 X \u251c\u2524 H \u251c\u2524 X \u251c\u2524 H \u251c\u2524 X \u251c\u2524 RY(0.1) \u251c\u2524 RY(0.5) \u251c\n                 \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> mark_state = Statevector.from_label('011')\n        >>> diffuse_operator = 2 * DensityMatrix.from_label('000') - Operator.from_label('III')\n        >>> grover_op = GroverOperator(oracle=mark_state, zero_reflection=diffuse_operator)\n        >>> grover_op.decompose().draw(fold=70)\n                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2510                          \u00bb\n        state_0: \u25240                \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\n                 \u2502                 \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2510          \u00bb\n        state_1: \u25241 UCRZ(0,pi,0,0) \u251c\u25240              \u251c\u2500\u2500\u2500\u2500\u2500\u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\n                 \u2502                 \u2502\u2502  UCRZ(pi/2,0) \u2502\u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u00bb\n        state_2: \u25242                \u251c\u25241              \u251c\u2524 UCRZ(-pi/4) \u251c\u2524 H \u251c\u00bb\n                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u00bb\n        \u00ab         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2510\n        \u00abstate_0: \u25240                \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        \u00ab         \u2502                 \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2510\n        \u00abstate_1: \u25241 UCRZ(pi,0,0,0) \u251c\u25240              \u251c\u2500\u2500\u2500\u2500\u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        \u00ab         \u2502                 \u2502\u2502  UCRZ(pi/2,0) \u2502\u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\n        \u00abstate_2: \u25242                \u251c\u25241              \u251c\u2524 UCRZ(pi/4) \u251c\u2524 H \u251c\n        \u00ab         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\n\n    .. seealso::\n\n        The :func:`.grover_operator` implements the same functionality but keeping the\n        :class:`.MCXGate` abstract, such that the compiler may choose the optimal decomposition.\n        We recommend using :func:`.grover_operator` for performance reasons, which does not\n        wrap the circuit into an opaque gate.\n\n    References:\n\n    [1] L. K. Grover (1996), A fast quantum mechanical algorithm for database search,\n    `arXiv:quant-ph/9605043 <https://arxiv.org/abs/quant-ph/9605043>`_.\n\n    [2] I. Chuang & M. Nielsen, Quantum Computation and Quantum Information,\n    Cambridge: Cambridge University Press, 2000. Chapter 6.1.2.\n\n    [3] Brassard, G., Hoyer, P., Mosca, M., & Tapp, A. (2000).\n    Quantum Amplitude Amplification and Estimation.\n    `arXiv:quant-ph/0005055 <http://arxiv.org/abs/quant-ph/0005055>`_.\n    ",
    "parameters": {
      "oracle": {
        "default": null,
        "annotation": "Union[QuantumCircuit, Statevector]"
      },
      "state_preparation": {
        "default": null,
        "annotation": "Optional[QuantumCircuit]"
      },
      "zero_reflection": {
        "default": null,
        "annotation": "Optional[Union[QuantumCircuit, DensityMatrix, Operator]]"
      },
      "reflection_qubits": {
        "default": null,
        "annotation": "Optional[List[int]]"
      },
      "insert_barriers": {
        "default": false,
        "annotation": "bool"
      },
      "mcx_mode": {
        "default": "noancilla",
        "annotation": "str"
      },
      "name": {
        "default": "Q",
        "annotation": "str"
      }
    }
  },
  {
    "class_name": "HRSCumulativeMultiplier",
    "module": "qiskit.circuit.library.arithmetic.multipliers.hrs_cumulative_multiplier",
    "doc": "A multiplication circuit to store product of two input registers out-of-place.\n\n    Circuit uses the approach from [1]. As an example, a multiplier circuit that\n    performs a non-modular multiplication on two 3-qubit sized registers with\n    the default adder is as follows (where ``Adder`` denotes the\n    ``CDKMRippleCarryAdder``):\n\n    .. code-block:: text\n\n          a_0: \u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                   \u2502\n          a_1: \u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                   \u2502         \u2502\n          a_2: \u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\n               \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\n          b_0: \u25240       \u251c\u25240       \u251c\u25240       \u251c\n               \u2502        \u2502\u2502        \u2502\u2502        \u2502\n          b_1: \u25241       \u251c\u25241       \u251c\u25241       \u251c\n               \u2502        \u2502\u2502        \u2502\u2502        \u2502\n          b_2: \u25242       \u251c\u25242       \u251c\u25242       \u251c\n               \u2502        \u2502\u2502        \u2502\u2502        \u2502\n        out_0: \u25243       \u251c\u2524        \u251c\u2524        \u251c\n               \u2502        \u2502\u2502        \u2502\u2502        \u2502\n        out_1: \u25244       \u251c\u25243       \u251c\u2524        \u251c\n               \u2502  Adder \u2502\u2502  Adder \u2502\u2502  Adder \u2502\n        out_2: \u25245       \u251c\u25244       \u251c\u25243       \u251c\n               \u2502        \u2502\u2502        \u2502\u2502        \u2502\n        out_3: \u25246       \u251c\u25245       \u251c\u25244       \u251c\n               \u2502        \u2502\u2502        \u2502\u2502        \u2502\n        out_4: \u2524        \u251c\u25246       \u251c\u25245       \u251c\n               \u2502        \u2502\u2502        \u2502\u2502        \u2502\n        out_5: \u2524        \u251c\u2524        \u251c\u25246       \u251c\n               \u2502        \u2502\u2502        \u2502\u2502        \u2502\n        aux_0: \u25247       \u251c\u25247       \u251c\u25247       \u251c\n               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Multiplication in this circuit is implemented in a classical approach by performing\n    a series of shifted additions using one of the input registers while the qubits\n    from the other input register act as control qubits for the adders.\n\n    .. seealso::\n\n        The :class:`.MultiplierGate` objects represents a multiplication, like this circuit class,\n        but allows the compiler to select the optimal decomposition based on the context.\n        Specific implementations can be set via the :class:`.HLSConfig`, e.g. this circuit\n        can be chosen via ``Multiplier=[\"cumulative_h18\"]``.\n\n    References:\n\n    [1] H\u00e4ner et al., Optimizing Quantum Circuits for Arithmetic, 2018.\n    `arXiv:1805.12445 <https://arxiv.org/pdf/1805.12445.pdf>`_\n\n    ",
    "parameters": {
      "num_state_qubits": {
        "default": null,
        "annotation": "<class 'int'>"
      },
      "num_result_qubits": {
        "default": null,
        "annotation": "typing.Optional[int]"
      },
      "adder": {
        "default": null,
        "annotation": "typing.Optional[qiskit.circuit.quantumcircuit.QuantumCircuit]"
      },
      "name": {
        "default": "HRSCumulativeMultiplier",
        "annotation": "<class 'str'>"
      }
    }
  },
  {
    "class_name": "HiddenLinearFunction",
    "module": "qiskit.circuit.library.hidden_linear_function",
    "doc": "Circuit to solve the hidden linear function problem.\n\n    The 2D Hidden Linear Function problem is determined by a 2D adjacency\n    matrix A, where only elements that are nearest-neighbor on a grid have\n    non-zero entries. Each row/column corresponds to one binary variable\n    :math:`x_i`.\n\n    The hidden linear function problem is as follows:\n\n    Consider the quadratic form\n\n    .. math::\n\n        q(x) = \\sum_{i,j=1}^{n}{x_i x_j} ~(\\mathrm{mod}~ 4)\n\n    and restrict :math:`q(x)` onto the nullspace of A. This results in a linear\n    function.\n\n    .. math::\n\n        2 \\sum_{i=1}^{n}{z_i x_i} ~(\\mathrm{mod}~ 4)  \\forall  x \\in \\mathrm{Ker}(A)\n\n    and the goal is to recover this linear function (equivalently a vector\n    :math:`[z_0, ..., z_{n-1}]`). There can be multiple solutions.\n\n    In [1] it is shown that the present circuit solves this problem\n    on a quantum computer in constant depth, whereas any corresponding\n    solution on a classical computer would require circuits that grow\n    logarithmically with :math:`n`. Thus this circuit is an example\n    of quantum advantage with shallow circuits.\n\n    Reference Circuit:\n\n    .. plot::\n        :alt: Diagram illustrating the previously described circuit.\n\n        from qiskit.circuit.library import HiddenLinearFunction\n        from qiskit.visualization.library import _generate_circuit_library_visualization\n        A = [[1, 1, 0], [1, 0, 1], [0, 1, 1]]\n        circuit = HiddenLinearFunction(A)\n        _generate_circuit_library_visualization(circuit)\n\n    References:\n\n    [1] S. Bravyi, D. Gosset, R. Koenig, Quantum Advantage with Shallow Circuits, 2017.\n    `arXiv:1704.00690 <https://arxiv.org/abs/1704.00690>`_\n    ",
    "parameters": {
      "adjacency_matrix": {
        "default": null,
        "annotation": "list | np.ndarray"
      }
    }
  },
  {
    "class_name": "IQP",
    "module": "qiskit.circuit.library.iqp",
    "doc": "Instantaneous quantum polynomial (IQP) circuit.\n\n    The circuit consists of a column of Hadamard gates,\n    a column of powers of T gates,\n    a sequence of powers of CS gates (up to\n    :math:`\\frac{n^2-n}{2}` of them),\n    and a final column of Hadamard gates, as introduced in [1].\n\n    The circuit is parameterized by an n x n interactions matrix.\n    The powers of each T gate are given by the diagonal elements\n    of the interactions matrix. The powers of the CS gates are\n    given by the upper triangle of the interactions matrix.\n\n    Reference Circuit:\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import IQP\n       A = [[6, 5, 3], [5, 4, 5], [3, 5, 1]]\n       circuit = IQP(A)\n       circuit.draw('mpl')\n\n    Expanded Circuit:\n\n    .. plot::\n        :alt: Diagram illustrating the previously described circuit.\n\n        from qiskit.circuit.library import IQP\n        from qiskit.visualization.library import _generate_circuit_library_visualization\n        A = [[6, 5, 3], [5, 4, 5], [3, 5, 1]]\n        circuit = IQP(A)\n        _generate_circuit_library_visualization(circuit.decompose())\n\n    References:\n\n    [1] M. J. Bremner et al. Average-case complexity versus approximate\n    simulation of commuting quantum computations,\n    Phys. Rev. Lett. 117, 080501 (2016).\n    `arXiv:1504.07999 <https://arxiv.org/abs/1504.07999>`_\n    ",
    "parameters": {
      "interactions": {
        "default": null,
        "annotation": "list | np.ndarray"
      }
    }
  },
  {
    "class_name": "InnerProduct",
    "module": "qiskit.circuit.library.boolean_logic.inner_product",
    "doc": "A 2n-qubit Boolean function that computes the inner product of\n    two n-qubit vectors over :math:`F_2`.\n\n    This implementation is a phase oracle which computes the following transform.\n\n    .. math::\n\n        \\mathcal{IP}_{2n} : F_2^{2n} \\rightarrow {-1, 1}\n        \\mathcal{IP}_{2n}(x_1, \\cdots, x_n, y_1, \\cdots, y_n) = (-1)^{x.y}\n\n    The corresponding unitary is a diagonal, which induces a -1 phase on any inputs\n    where the inner product of the top and bottom registers is 1. Otherwise it keeps\n    the input intact.\n\n    .. code-block:: text\n\n\n        q0_0: \u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n               \u2502\n        q0_1: \u2500\u253c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n               \u2502  \u2502\n        q0_2: \u2500\u253c\u2500\u2500\u253c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\n               \u2502  \u2502  \u2502\n        q0_3: \u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u25a0\u2500\n               \u2502  \u2502  \u2502  \u2502\n        q1_0: \u2500\u25a0\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\n                  \u2502  \u2502  \u2502\n        q1_1: \u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u253c\u2500\u2500\u253c\u2500\n                     \u2502  \u2502\n        q1_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u253c\u2500\n                        \u2502\n        q1_3: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\n\n\n    Reference Circuit:\n        .. plot::\n           :alt: Diagram illustrating the previously described circuit.\n\n           from qiskit.circuit.library import InnerProduct\n           from qiskit.visualization.library import _generate_circuit_library_visualization\n           circuit = InnerProduct(4)\n           _generate_circuit_library_visualization(circuit)\n    ",
    "parameters": {
      "num_qubits": {
        "default": null,
        "annotation": "<class 'int'>"
      }
    }
  },
  {
    "class_name": "IntegerComparator",
    "module": "qiskit.circuit.library.arithmetic.integer_comparator",
    "doc": "Integer Comparator.\n\n    Operator compares basis states :math:`|i\\rangle_n` against a classically given integer\n    :math:`L` of fixed value and flips a target qubit if :math:`i \\geq L`\n    (or :math:`<` depending on the parameter ``geq``):\n\n    .. math::\n\n        |i\\rangle_n |0\\rangle \\mapsto |i\\rangle_n |i \\geq L\\rangle\n\n    This operation is based on two's complement implementation of binary subtraction but only\n    uses carry bits and no actual result bits. If the most significant carry bit\n    (the results bit) is 1, the :math:`\\geq` condition is ``True`` otherwise it is ``False``.\n    ",
    "parameters": {
      "num_state_qubits": {
        "default": null,
        "annotation": "int | None"
      },
      "value": {
        "default": null,
        "annotation": "int | None"
      },
      "geq": {
        "default": true,
        "annotation": "bool"
      },
      "name": {
        "default": "cmp",
        "annotation": "str"
      }
    }
  },
  {
    "class_name": "LinearAmplitudeFunctionGate",
    "module": "qiskit.circuit.library.arithmetic.linear_amplitude_function",
    "doc": "A circuit implementing a (piecewise) linear function on qubit amplitudes.\n\n    An amplitude function :math:`F` of a function :math:`f` is a mapping\n\n    .. math::\n\n        F|x\\rangle|0\\rangle = \\sqrt{1 - \\hat{f}(x)} |x\\rangle|0\\rangle + \\sqrt{\\hat{f}(x)}\n            |x\\rangle|1\\rangle.\n\n    for a function :math:`\\hat{f}: \\{ 0, ..., 2^n - 1 \\} \\rightarrow [0, 1]`, where\n    :math:`|x\\rangle` is a :math:`n` qubit state.\n\n    This circuit implements :math:`F` for piecewise linear functions :math:`\\hat{f}`.\n    In this case, the mapping :math:`F` can be approximately implemented using a Taylor expansion\n    and linearly controlled Pauli-Y rotations, see [1, 2] for more detail. This approximation\n    uses a ``rescaling_factor`` to determine the accuracy of the Taylor expansion.\n\n    In general, the function of interest :math:`f` is defined from some interval :math:`[a,b]`,\n    the ``domain`` to :math:`[c,d]`, the ``image``, instead of :math:`\\{ 1, ..., N \\}` to\n    :math:`[0, 1]`. Using an affine transformation we can rescale :math:`f` to :math:`\\hat{f}`:\n\n    .. math::\n\n        \\hat{f}(x) = \\frac{f(\\phi(x)) - c}{d - c}\n\n    with\n\n    .. math::\n\n        \\phi(x) = a + \\frac{b - a}{2^n - 1} x.\n\n    If :math:`f` is a piecewise linear function on :math:`m` intervals\n    :math:`[p_{i-1}, p_i], i \\in \\{1, ..., m\\}` with slopes :math:`\\alpha_i` and\n    offsets :math:`\\beta_i` it can be written as\n\n    .. math::\n\n        f(x) = \\sum_{i=1}^m 1_{[p_{i-1}, p_i]}(x) (\\alpha_i x + \\beta_i)\n\n    where :math:`1_{[a, b]}` is an indication function that is 1 if the argument is in the interval\n    :math:`[a, b]` and otherwise 0. The breakpoints :math:`p_i` can be specified by the\n    ``breakpoints`` argument.\n\n    References:\n\n    [1] Woerner, S., & Egger, D. J. (2018). Quantum Risk Analysis.\n    `arXiv:1806.06893 <http://arxiv.org/abs/1806.06893>`_\n\n    [2] Gacon, J., Zoufal, C., & Woerner, S. (2020). Quantum-Enhanced Simulation-Based Optimization.\n    `arXiv:2005.10780 <http://arxiv.org/abs/2005.10780>`_\n    ",
    "parameters": {
      "num_state_qubits": {
        "default": null,
        "annotation": "int"
      },
      "slope": {
        "default": null,
        "annotation": "float | list[float]"
      },
      "offset": {
        "default": null,
        "annotation": "float | list[float]"
      },
      "domain": {
        "default": null,
        "annotation": "tuple[float, float]"
      },
      "image": {
        "default": null,
        "annotation": "tuple[float, float]"
      },
      "rescaling_factor": {
        "default": 1,
        "annotation": "float"
      },
      "breakpoints": {
        "default": null,
        "annotation": "list[float] | None"
      },
      "name": {
        "default": "F",
        "annotation": "str"
      }
    }
  },
  {
    "class_name": "LinearPauliRotations",
    "module": "qiskit.circuit.library.arithmetic.linear_pauli_rotations",
    "doc": "Linearly-controlled X, Y or Z rotation.\n\n    For a register of state qubits :math:`|x\\rangle`, a target qubit :math:`|0\\rangle` and the\n    basis ``'Y'`` this circuit acts as:\n\n    .. code-block:: text\n\n            q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 ... \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                                          \u2502\n                                          .\n                                          \u2502\n        q_(n-1): \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 ... \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            q_n: \u2500\u2524 RY(offset) \u251c\u2500\u2500\u2524 RY(2^0 slope) \u251c  ...  \u2524 RY(2^(n-1) slope) \u251c\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    This can for example be used to approximate linear functions, with :math:`a =` ``slope``:math:`/2`\n    and :math:`b =` ``offset``:math:`/2` and the basis ``'Y'``:\n\n    .. math::\n\n        |x\\rangle |0\\rangle \\mapsto \\cos(ax + b)|x\\rangle|0\\rangle + \\sin(ax + b)|x\\rangle |1\\rangle\n\n    Since for small arguments :math:`\\sin(x) \\approx x` this operator can be used to approximate\n    linear functions.\n    ",
    "parameters": {
      "num_state_qubits": {
        "default": null,
        "annotation": "Optional[int]"
      },
      "slope": {
        "default": 1,
        "annotation": "float"
      },
      "offset": {
        "default": 0,
        "annotation": "float"
      },
      "basis": {
        "default": "Y",
        "annotation": "str"
      },
      "name": {
        "default": "LinRot",
        "annotation": "str"
      }
    }
  },
  {
    "class_name": "MCMTGate",
    "module": "qiskit.circuit.library.generalized_gates.mcmt",
    "doc": "The multi-controlled multi-target gate, for an arbitrary singly controlled target gate.\n\n    For example, the H gate controlled on 3 qubits and acting on 2 target qubit is represented as:\n\n    .. code-block:: text\n\n        \u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\n           \u2502\n        \u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\n           \u2502\n        \u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\n        \u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2510\n        \u25240     \u251c\n        \u2502  2-H \u2502\n        \u25241     \u251c\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    This default implementations requires no ancilla qubits, by broadcasting the target gate\n    to the number of target qubits and using Qiskit's generic control routine to control the\n    broadcasted target on the control qubits. If ancilla qubits are available, a more efficient\n    variant using the so-called V-chain decomposition can be used. This is implemented in\n    :class:`~qiskit.circuit.library.MCMTVChain`.\n    ",
    "parameters": {
      "gate": {
        "default": null,
        "annotation": "Gate | Callable[[QuantumCircuit, circuit.Qubit, circuit.Qubit], circuit.Instruction]"
      },
      "num_ctrl_qubits": {
        "default": null,
        "annotation": "int"
      },
      "num_target_qubits": {
        "default": null,
        "annotation": "int"
      }
    }
  },
  {
    "class_name": "MCMTVChain",
    "module": "qiskit.circuit.library.generalized_gates.mcmt",
    "doc": "The MCMT implementation using the CCX V-chain.\n\n    This implementation requires ancillas but is decomposed into a much shallower circuit\n    than the default implementation in :class:`~qiskit.circuit.library.MCMT`.\n\n    Expanded circuit:\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import MCMTVChain, ZGate\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       circuit = MCMTVChain(ZGate(), 2, 2)\n       _generate_circuit_library_visualization(circuit.decompose())\n\n    Examples:\n\n        >>> from qiskit.circuit.library import HGate\n        >>> MCMTVChain(HGate(), 3, 2).draw()\n\n        q_0: \u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\n               \u2502                        \u2502\n        q_1: \u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\n               \u2502                        \u2502\n        q_2: \u2500\u2500\u253c\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\n               \u2502    \u2502  \u250c\u2500\u2500\u2500\u2510       \u2502    \u2502\n        q_3: \u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\n               \u2502    \u2502  \u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510  \u2502    \u2502\n        q_4: \u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 H \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\n             \u250c\u2500\u2534\u2500\u2510  \u2502    \u2502  \u2514\u2500\u252c\u2500\u2518  \u2502  \u250c\u2500\u2534\u2500\u2510\n        q_5: \u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\n             \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510  \u2502    \u2502  \u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518\n        q_6: \u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\n                  \u2514\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2518\n    ",
    "parameters": {
      "gate": {
        "default": null,
        "annotation": "Gate | Callable[[QuantumCircuit, circuit.Qubit, circuit.Qubit], circuit.Instruction]"
      },
      "num_ctrl_qubits": {
        "default": null,
        "annotation": "int"
      },
      "num_target_qubits": {
        "default": null,
        "annotation": "int"
      }
    }
  },
  {
    "class_name": "NLocal",
    "module": "qiskit.circuit.library.n_local.n_local",
    "doc": "The n-local circuit class.\n\n    The structure of the n-local circuit are alternating rotation and entanglement layers.\n    In both layers, parameterized circuit-blocks act on the circuit in a defined way.\n    In the rotation layer, the blocks are applied stacked on top of each other, while in the\n    entanglement layer according to the ``entanglement`` strategy.\n    The circuit blocks can have arbitrary sizes (smaller equal to the number of qubits in the\n    circuit). Each layer is repeated ``reps`` times, and by default a final rotation layer is\n    appended.\n\n    For instance, a rotation block on 2 qubits and an entanglement block on 4 qubits using\n    ``'linear'`` entanglement yields the following circuit.\n\n    .. code-block:: text\n\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510                      \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u25240     \u251c\u2500\u2591\u2500\u25240     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 ... \u2500\u2591\u2500\u25240     \u251c\n        \u2502  Rot \u2502 \u2591 \u2502      \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2591 \u2502  Rot \u2502\n        \u25241     \u251c\u2500\u2591\u2500\u25241     \u251c\u25240     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 ... \u2500\u2591\u2500\u25241     \u251c\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u2502  Ent \u2502\u2502      \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u25240     \u251c\u2500\u2591\u2500\u25242     \u251c\u25241     \u251c\u25240     \u251c ... \u2500\u2591\u2500\u25240     \u251c\n        \u2502  Rot \u2502 \u2591 \u2502      \u2502\u2502  Ent \u2502\u2502      \u2502      \u2591 \u2502  Rot \u2502\n        \u25241     \u251c\u2500\u2591\u2500\u25243     \u251c\u25242     \u251c\u25241     \u251c ... \u2500\u2591\u2500\u25241     \u251c\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502      \u2502\u2502  Ent \u2502      \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u25240     \u251c\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25243     \u251c\u25242     \u251c ... \u2500\u2591\u2500\u25240     \u251c\n        \u2502  Rot \u2502 \u2591         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502      \u2502      \u2591 \u2502  Rot \u2502\n        \u25241     \u251c\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25243     \u251c ... \u2500\u2591\u2500\u25241     \u251c\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        |                                 |\n        +---------------------------------+\n               repeated reps times\n\n    If specified, barriers can be inserted in between every block.\n    If an initial state object is provided, it is added in front of the NLocal.\n\n    .. seealso::\n\n        The :func:`.n_local` function constructs a functionally equivalent circuit, but faster.\n\n    ",
    "parameters": {
      "num_qubits": {
        "default": null,
        "annotation": "int | None"
      },
      "rotation_blocks": {
        "default": null,
        "annotation": "QuantumCircuit | list[QuantumCircuit] | qiskit.circuit.Instruction | list[qiskit.circuit.Instruction] | None"
      },
      "entanglement_blocks": {
        "default": null,
        "annotation": "QuantumCircuit | list[QuantumCircuit] | qiskit.circuit.Instruction | list[qiskit.circuit.Instruction] | None"
      },
      "entanglement": {
        "default": null,
        "annotation": "list[int] | list[list[int]] | None"
      },
      "reps": {
        "default": 1,
        "annotation": "int"
      },
      "insert_barriers": {
        "default": false,
        "annotation": "bool"
      },
      "parameter_prefix": {
        "default": "\u03b8",
        "annotation": "str"
      },
      "overwrite_block_parameters": {
        "default": true,
        "annotation": "bool | list[list[Parameter]]"
      },
      "skip_final_rotation_layer": {
        "default": false,
        "annotation": "bool"
      },
      "skip_unentangled_qubits": {
        "default": false,
        "annotation": "bool"
      },
      "initial_state": {
        "default": null,
        "annotation": "QuantumCircuit | None"
      },
      "name": {
        "default": "nlocal",
        "annotation": "str | None"
      },
      "flatten": {
        "default": null,
        "annotation": "bool | None"
      }
    }
  },
  {
    "class_name": "OR",
    "module": "qiskit.circuit.library.boolean_logic.quantum_or",
    "doc": "A circuit implementing the logical OR operation on a number of qubits.\n\n    For the OR operation the state :math:`|1\\rangle` is interpreted as ``True``. The result\n    qubit is flipped, if the state of any variable qubit is ``True``. The OR is implemented using\n    a multi-open-controlled X gate (i.e. flips if the state is :math:`|0\\rangle`) and\n    applying an X gate on the result qubit.\n    Using a list of flags, qubits can be skipped or negated.\n\n    The OR gate without special flags:\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import OR\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       circuit = OR(5)\n       _generate_circuit_library_visualization(circuit)\n\n    Using flags we can negate qubits or skip them. For instance, if we have 5 qubits and want to\n    return ``True`` if the first qubit is ``False`` or one of the last two are ``True`` we use the\n    flags ``[-1, 0, 0, 1, 1]``.\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import OR\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       circuit = OR(5, flags=[-1, 0, 0, 1, 1])\n       _generate_circuit_library_visualization(circuit)\n\n    ",
    "parameters": {
      "num_variable_qubits": {
        "default": null,
        "annotation": "int"
      },
      "flags": {
        "default": null,
        "annotation": "Optional[List[int]]"
      },
      "mcx_mode": {
        "default": "noancilla",
        "annotation": "str"
      }
    }
  },
  {
    "class_name": "PauliFeatureMap",
    "module": "qiskit.circuit.library.data_preparation.pauli_feature_map",
    "doc": "The Pauli Expansion circuit.\n\n    The Pauli Expansion circuit is a data encoding circuit that transforms input data\n    :math:`\\vec{x} \\in \\mathbb{R}^n`, where `n` is the ``feature_dimension``, as\n\n    .. math::\n\n        U_{\\Phi(\\vec{x})}=\\exp\\left(i\\sum_{S \\in \\mathcal{I}}\n        \\phi_S(\\vec{x})\\prod_{i\\in S} P_i\\right).\n\n    Here, :math:`S` is a set of qubit indices that describes the connections in the feature map,\n    :math:`\\mathcal{I}` is a set containing all these index sets, and\n    :math:`P_i \\in \\{I, X, Y, Z\\}`. Per default the data-mapping\n    :math:`\\phi_S` is\n\n    .. math::\n\n        \\phi_S(\\vec{x}) = \\begin{cases}\n            x_i \\text{ if } S = \\{i\\} \\\\\n            \\prod_{j \\in S} (\\pi - x_j) \\text{ if } |S| > 1\n            \\end{cases}.\n\n    The possible connections can be set using the ``entanglement`` and ``paulis`` arguments.\n    For example, for single-qubit :math:`Z` rotations and two-qubit :math:`YY` interactions\n    between all qubit pairs, we can set::\n\n\n        feature_map = PauliFeatureMap(..., paulis=[\"Z\", \"YY\"], entanglement=\"full\")\n\n    which will produce blocks of the form\n\n    .. code-block:: text\n\n        \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2524 H \u251c\u2524 P(2.0*x[0]) \u251c\u2524 RX(pi/2) \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 RX(-pi/2) \u251c\n        \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2524 H \u251c\u2524 P(2.0*x[1]) \u251c\u2524 RX(pi/2) \u251c\u2524 X \u251c\u2524 P(2.0*(pi - x[0])*(pi - x[1])) \u251c\u2524 X \u251c\u2524 RX(-pi/2) \u251c\n        \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    The circuit contains ``reps`` repetitions of this transformation.\n\n    Please refer to :class:`.ZFeatureMap` for the case of single-qubit Pauli-:math:`Z` rotations\n    and to :class:`.ZZFeatureMap` for the single- and two-qubit Pauli-:math:`Z` rotations.\n\n    Examples:\n\n        >>> prep = PauliFeatureMap(2, reps=1, paulis=['ZZ'])\n        >>> print(prep.decompose())\n             \u250c\u2500\u2500\u2500\u2510\n        q_0: \u2524 H \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\n             \u251c\u2500\u2500\u2500\u2524\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\n        q_1: \u2524 H \u251c\u2524 X \u251c\u2524 P(2.0*(pi - x[0])*(pi - x[1])) \u251c\u2524 X \u251c\n             \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\n\n        >>> prep = PauliFeatureMap(2, reps=1, paulis=['Z', 'XX'])\n        >>> print(prep.decompose())\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510                                            \u250c\u2500\u2500\u2500\u2510\n        q_0: \u2524 H \u251c\u2524 P(2.0*x[0]) \u251c\u2524 H \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 H \u251c\n             \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2524\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u251c\u2500\u2500\u2500\u2524\n        q_1: \u2524 H \u251c\u2524 P(2.0*x[1]) \u251c\u2524 H \u251c\u2524 X \u251c\u2524 P(2.0*(pi - x[0])*(pi - x[1])) \u251c\u2524 X \u251c\u2524 H \u251c\n             \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\n\n        >>> prep = PauliFeatureMap(2, reps=1, paulis=['ZY'])\n        >>> print(prep.decompose())\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 H \u251c\u2524 RX(pi/2) \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 RX(-pi/2) \u251c\n             \u251c\u2500\u2500\u2500\u2524\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        q_1: \u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2524 P(2.0*(pi - x[0])*(pi - x[1])) \u251c\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\n\n        >>> from qiskit.circuit.library import EfficientSU2\n        >>> prep = PauliFeatureMap(3, reps=3, paulis=['Z', 'YY', 'ZXZ'])\n        >>> wavefunction = EfficientSU2(3)\n        >>> classifier = prep.compose(wavefunction)\n        >>> classifier.num_parameters\n        27\n        >>> classifier.count_ops()\n        OrderedDict([('cx', 39), ('rx', 36), ('u1', 21), ('h', 15), ('ry', 12), ('rz', 12)])\n\n    References:\n\n    [1] Havlicek et al. Supervised learning with quantum enhanced feature spaces,\n    `Nature 567, 209-212 (2019) <https://www.nature.com/articles/s41586-019-0980-2>`__.\n    ",
    "parameters": {
      "feature_dimension": {
        "default": null,
        "annotation": "Optional[int]"
      },
      "reps": {
        "default": 2,
        "annotation": "int"
      },
      "entanglement": {
        "default": "full",
        "annotation": "Union[str, Dict[int, List[Tuple[int]]], Callable[[int], Union[str, Dict[int, List[Tuple[int]]]]]]"
      },
      "alpha": {
        "default": 2.0,
        "annotation": "float"
      },
      "paulis": {
        "default": null,
        "annotation": "Optional[List[str]]"
      },
      "data_map_func": {
        "default": null,
        "annotation": "Optional[Callable[[np.ndarray], float]]"
      },
      "parameter_prefix": {
        "default": "x",
        "annotation": "str"
      },
      "insert_barriers": {
        "default": false,
        "annotation": "bool"
      },
      "name": {
        "default": "PauliFeatureMap",
        "annotation": "str"
      }
    }
  },
  {
    "class_name": "PauliTwoDesign",
    "module": "qiskit.circuit.library.n_local.pauli_two_design",
    "doc": "The Pauli Two-Design ansatz.\n\n    This class implements a particular form of a 2-design circuit [1], which is frequently studied\n    in quantum machine learning literature, such as e.g. the investigating of Barren plateaus in\n    variational algorithms [2].\n\n    The circuit consists of alternating rotation and entanglement layers with\n    an initial layer of :math:`\\sqrt{H} = RY(\\pi/4)` gates.\n    The rotation layers contain single qubit Pauli rotations, where the axis is chosen uniformly\n    at random to be X, Y or Z. The entanglement layers is compromised of pairwise CZ gates\n    with a total depth of 2.\n\n    For instance, the circuit could look like this (but note that choosing a different seed\n    yields different Pauli rotations).\n\n    .. code-block:: text\n\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2591  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 RY(\u03c0/4) \u251c\u2524 RZ(\u03b8[0]) \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 RY(\u03b8[4]) \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u2524 RZ(\u03b8[8]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502     \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502     \u2591  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_1: \u2524 RY(\u03c0/4) \u251c\u2524 RZ(\u03b8[1]) \u251c\u2500\u25a0\u2500\u2500\u25a0\u2500\u2500\u2591\u2500\u2524 RY(\u03b8[5]) \u251c\u2500\u25a0\u2500\u2500\u25a0\u2500\u2500\u2591\u2500\u2500\u2524 RX(\u03b8[9]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524    \u2502  \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524    \u2502  \u2591 \u250c\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_2: \u2524 RY(\u03c0/4) \u251c\u2524 RX(\u03b8[2]) \u251c\u2500\u25a0\u2500\u2500\u25a0\u2500\u2500\u2591\u2500\u2524 RY(\u03b8[6]) \u251c\u2500\u25a0\u2500\u2500\u25a0\u2500\u2500\u2591\u2500\u2524 RX(\u03b8[10]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502     \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502     \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_3: \u2524 RY(\u03c0/4) \u251c\u2524 RZ(\u03b8[3]) \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 RX(\u03b8[7]) \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 RY(\u03b8[11]) \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Examples:\n\n        .. plot::\n           :alt: Circuit diagram output by the previous code.\n           :include-source:\n\n           from qiskit.circuit.library import PauliTwoDesign\n           circuit = PauliTwoDesign(4, reps=2, seed=5, insert_barriers=True)\n           circuit.draw('mpl')\n\n    .. seealso::\n\n        The :func:`.pauli_two_design` function constructs the functionally same circuit, but faster.\n\n    References:\n\n        [1]: Nakata et al., Unitary 2-designs from random X- and Z-diagonal unitaries.\n            `arXiv:1502.07514 <https://arxiv.org/pdf/1502.07514.pdf>`_\n\n        [2]: McClean et al., Barren plateaus in quantum neural network training landscapes.\n             `arXiv:1803.11173 <https://arxiv.org/pdf/1803.11173.pdf>`_\n    ",
    "parameters": {
      "num_qubits": {
        "default": null,
        "annotation": "int | None"
      },
      "reps": {
        "default": 3,
        "annotation": "int"
      },
      "seed": {
        "default": null,
        "annotation": "int | None"
      },
      "insert_barriers": {
        "default": false,
        "annotation": "bool"
      },
      "name": {
        "default": "PauliTwoDesign",
        "annotation": "str"
      }
    }
  },
  {
    "class_name": "PermutationGate",
    "module": "qiskit.circuit.library.generalized_gates.permutation",
    "doc": "An n_qubit circuit that permutes qubits.",
    "parameters": {
      "num_qubits": {
        "default": null,
        "annotation": "int"
      },
      "pattern": {
        "default": null,
        "annotation": "list[int] | np.ndarray | None"
      },
      "seed": {
        "default": null,
        "annotation": "int | None"
      }
    }
  },
  {
    "class_name": "PhaseEstimation",
    "module": "qiskit.circuit.library.phase_estimation",
    "doc": "Phase Estimation circuit.\n\n    In the Quantum Phase Estimation (QPE) algorithm [1, 2, 3], the Phase Estimation circuit is used\n    to estimate the phase :math:`\\phi` of an eigenvalue :math:`e^{2\\pi i\\phi}` of a unitary operator\n    :math:`U`, provided with the corresponding eigenstate :math:`|\\psi\\rangle`.\n    That is\n\n    .. math::\n\n        U|\\psi\\rangle = e^{2\\pi i\\phi} |\\psi\\rangle\n\n    This estimation (and thereby this circuit) is a central routine to several well-known\n    algorithms, such as Shor's algorithm or Quantum Amplitude Estimation.\n\n    References:\n\n    [1] Kitaev, A. Y. (1995). Quantum measurements and the Abelian Stabilizer Problem. 1\u201322.\n    `quant-ph/9511026 <http://arxiv.org/abs/quant-ph/9511026>`_\n\n    [2] Michael A. Nielsen and Isaac L. Chuang. 2011.\n    Quantum Computation and Quantum Information: 10th Anniversary Edition (10th ed.).\n    Cambridge University Press, New York, NY, USA.\n\n    [3] Qiskit\n    `textbook <https://github.com/Qiskit/textbook/blob/main/notebooks/ch-algorithms/\n    quantum-phase-estimation.ipynb>`_\n\n    ",
    "parameters": {
      "num_evaluation_qubits": {
        "default": null,
        "annotation": "int"
      },
      "unitary": {
        "default": null,
        "annotation": "QuantumCircuit"
      },
      "iqft": {
        "default": null,
        "annotation": "QuantumCircuit | None"
      },
      "name": {
        "default": "QPE",
        "annotation": "str"
      }
    }
  },
  {
    "class_name": "PhaseOracleGate",
    "module": "qiskit.circuit.library.phase_oracle",
    "doc": "Phase Oracle.\n\n    The Phase Oracle object constructs circuits for any arbitrary\n    input logical expressions. A logical expression is composed of logical operators\n    `&` (logical `AND`), `|` (logical  `OR`),\n    `~` (logical  `NOT`), and `^` (logical  `XOR`).\n    as well as symbols for literals (variables).\n    For example, `'a & b'`, and `(v0 | ~v1) & (~v2 & v3)`\n    are both valid string representation of boolean logical expressions.\n\n    A phase oracle for a boolean function `f(x)` performs the following\n    quantum operation:\n\n    .. math::\n\n            |x\\rangle \\mapsto (-1)^{f(x)}|x\\rangle\n\n    For convenience, this oracle, in addition to parsing arbitrary logical expressions,\n    also supports input strings in the `DIMACS CNF format\n    <https://web.archive.org/web/20190325181937/https://www.satcompetition.org/2009/format-benchmarks2009.html>`__,\n    which is the standard format for specifying SATisfiability (SAT) problem instances in\n    `Conjunctive Normal Form (CNF) <https://en.wikipedia.org/wiki/Conjunctive_normal_form>`__,\n    which is a conjunction of one or more clauses, where a clause is a disjunction of one\n    or more literals. See :meth:`qiskit.circuit.library.phase_oracle.PhaseOracle.from_dimacs_file`.\n\n    From 16 variables on, possible performance issues should be expected when using the\n    default synthesizer.\n    ",
    "parameters": {
      "expression": {
        "default": null,
        "annotation": "str | BooleanExpression"
      },
      "var_order": {
        "default": null,
        "annotation": "list[str] | None"
      }
    }
  },
  {
    "class_name": "PiecewiseChebyshev",
    "module": "qiskit.circuit.library.arithmetic.piecewise_chebyshev",
    "doc": "Piecewise Chebyshev approximation to an input function.\n\n    For a given function :math:`f(x)` and degree :math:`d`, this class implements a piecewise\n    polynomial Chebyshev approximation on :math:`n` qubits to :math:`f(x)` on the given intervals.\n    All the polynomials in the approximation are of degree :math:`d`.\n\n    The values of the parameters are calculated according to [1] and see [2] for a more\n    detailed explanation of the circuit construction and how it acts on the qubits.\n\n    Examples:\n\n    .. plot::\n        :alt: Circuit diagram output by the previous code.\n        :include-source:\n\n        import numpy as np\n        from qiskit import QuantumCircuit\n        from qiskit.circuit.library.arithmetic.piecewise_chebyshev import PiecewiseChebyshev\n        f_x, degree, breakpoints, num_state_qubits = lambda x: np.arcsin(1 / x), 2, [2, 4], 2\n        pw_approximation = PiecewiseChebyshev(f_x, degree, breakpoints, num_state_qubits)\n        pw_approximation._build()\n        qc = QuantumCircuit(pw_approximation.num_qubits)\n        qc.h(list(range(num_state_qubits)))\n        qc.append(pw_approximation.to_instruction(), qc.qubits)\n        qc.draw(output='mpl')\n\n    References:\n\n    [1] Haener, T., Roetteler, M., & Svore, K. M. (2018).\n    Optimizing Quantum Circuits for Arithmetic.\n    `arXiv:1805.12445 <http://arxiv.org/abs/1805.12445>`_\n\n    [2] Carrera Vazquez, A., Hiptmair, H., & Woerner, S. (2022).\n    Enhancing the Quantum Linear Systems Algorithm Using Richardson Extrapolation.\n    `ACM Transactions on Quantum Computing 3, 1, Article 2 <https://doi.org/10.1145/3490631>`_\n    ",
    "parameters": {
      "f_x": {
        "default": null,
        "annotation": "float | Callable[[int], float]"
      },
      "degree": {
        "default": null,
        "annotation": "int | None"
      },
      "breakpoints": {
        "default": null,
        "annotation": "list[int] | None"
      },
      "num_state_qubits": {
        "default": null,
        "annotation": "int | None"
      },
      "name": {
        "default": "pw_cheb",
        "annotation": "str"
      }
    }
  },
  {
    "class_name": "PiecewiseLinearPauliRotations",
    "module": "qiskit.circuit.library.arithmetic.piecewise_linear_pauli_rotations",
    "doc": "Piecewise-linearly-controlled Pauli rotations.\n\n    For a piecewise linear (not necessarily continuous) function :math:`f(x)`, which is defined\n    through breakpoints, slopes and offsets as follows.\n    Suppose the breakpoints :math:`(x_0, ..., x_J)` are a subset of :math:`[0, 2^n-1]`, where\n    :math:`n` is the number of state qubits. Further on, denote the corresponding slopes and\n    offsets by :math:`a_j` and :math:`b_j` respectively.\n    Then f(x) is defined as:\n\n    .. math::\n\n        f(x) = \\begin{cases}\n            0, x < x_0 \\\\\n            a_j (x - x_j) + b_j, x_j \\leq x < x_{j+1}\n            \\end{cases}\n\n    where we implicitly assume :math:`x_{J+1} = 2^n`.\n    ",
    "parameters": {
      "num_state_qubits": {
        "default": null,
        "annotation": "int | None"
      },
      "breakpoints": {
        "default": null,
        "annotation": "list[int] | None"
      },
      "slopes": {
        "default": null,
        "annotation": "list[float] | np.ndarray | None"
      },
      "offsets": {
        "default": null,
        "annotation": "list[float] | np.ndarray | None"
      },
      "basis": {
        "default": "Y",
        "annotation": "str"
      },
      "name": {
        "default": "pw_lin",
        "annotation": "str"
      }
    }
  },
  {
    "class_name": "PolynomialPauliRotations",
    "module": "qiskit.circuit.library.arithmetic.polynomial_pauli_rotations",
    "doc": "A circuit implementing polynomial Pauli rotations.\n\n    For a polynomial :math:`p(x)`, a basis state :math:`|i\\rangle` and a target qubit\n    :math:`|0\\rangle` this operator acts as:\n\n    .. math::\n\n        |i\\rangle |0\\rangle \\mapsto \\cos\\left(\\frac{p(i)}{2}\\right) |i\\rangle |0\\rangle\n        + \\sin\\left(\\frac{p(i)}{2}\\right) |i\\rangle |1\\rangle\n\n    Let n be the number of qubits representing the state, d the degree of p(x) and q_i the qubits,\n    where q_0 is the least significant qubit. Then for\n\n    .. math::\n\n        x = \\sum_{i=0}^{n-1} 2^i q_i,\n\n    we can write\n\n    .. math::\n\n        p(x) = \\sum_{j=0}^{j=d} c_j x^j\n\n    where :math:`c` are the input coefficients, ``coeffs``.\n    ",
    "parameters": {
      "num_state_qubits": {
        "default": null,
        "annotation": "int | None"
      },
      "coeffs": {
        "default": null,
        "annotation": "list[float] | None"
      },
      "basis": {
        "default": "Y",
        "annotation": "str"
      },
      "name": {
        "default": "poly",
        "annotation": "str"
      }
    }
  },
  {
    "class_name": "QAOAAnsatz",
    "module": "qiskit.circuit.library.n_local.qaoa_ansatz",
    "doc": "A generalized QAOA quantum circuit with a support of custom initial states and mixers.\n\n    References:\n\n    [1] Farhi et al., A Quantum Approximate Optimization Algorithm.\n    `arXiv:1411.4028 <https://arxiv.org/pdf/1411.4028>`_\n    ",
    "parameters": {
      "cost_operator": {
        "default": null,
        "annotation": null
      },
      "reps": {
        "default": 1,
        "annotation": "int"
      },
      "initial_state": {
        "default": null,
        "annotation": "QuantumCircuit | None"
      },
      "mixer_operator": {
        "default": null,
        "annotation": null
      },
      "name": {
        "default": "QAOA",
        "annotation": "str"
      },
      "flatten": {
        "default": null,
        "annotation": "bool | None"
      }
    }
  },
  {
    "class_name": "QFT",
    "module": "qiskit.circuit.library.basis_change.qft",
    "doc": "Quantum Fourier Transform Circuit.\n\n    The Quantum Fourier Transform (QFT) on :math:`n` qubits is the operation\n\n    .. math::\n\n        |j\\rangle \\mapsto \\frac{1}{2^{n/2}} \\sum_{k=0}^{2^n - 1} e^{2\\pi ijk / 2^n} |k\\rangle\n\n    The circuit that implements this transformation can be implemented using Hadamard gates\n    on each qubit, a series of controlled-U1 (or Z, depending on the phase) gates and a\n    layer of Swap gates. The layer of Swap gates can in principle be dropped if the QFT appears\n    at the end of the circuit, since then the re-ordering can be done classically. They\n    can be turned off using the ``do_swaps`` attribute.\n\n    For 4 qubits, the circuit that implements this transformation is:\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import QFT\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       circuit = QFT(4)\n       _generate_circuit_library_visualization(circuit)\n\n    The inverse QFT can be obtained by calling the ``inverse`` method on this class.\n    The respective circuit diagram is:\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import QFT\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       circuit = QFT(4).inverse()\n       _generate_circuit_library_visualization(circuit)\n\n    One method to reduce circuit depth is to implement the QFT approximately by ignoring\n    controlled-phase rotations where the angle is beneath a threshold. This is discussed\n    in more detail in https://arxiv.org/abs/quant-ph/9601018 or\n    https://arxiv.org/abs/quant-ph/0403071.\n\n    Here, this can be adjusted using the ``approximation_degree`` attribute: the smallest\n    ``approximation_degree`` rotation angles are dropped from the QFT. For instance, a QFT\n    on 5 qubits with approximation degree 2 yields (the barriers are dropped in this example):\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import QFT\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       circuit = QFT(5, approximation_degree=2)\n       _generate_circuit_library_visualization(circuit)\n\n    ",
    "parameters": {
      "num_qubits": {
        "default": null,
        "annotation": "int | None"
      },
      "approximation_degree": {
        "default": 0,
        "annotation": "int"
      },
      "do_swaps": {
        "default": true,
        "annotation": "bool"
      },
      "inverse": {
        "default": false,
        "annotation": "bool"
      },
      "insert_barriers": {
        "default": false,
        "annotation": "bool"
      },
      "name": {
        "default": null,
        "annotation": "str | None"
      }
    }
  },
  {
    "class_name": "QuadraticForm",
    "module": "qiskit.circuit.library.arithmetic.quadratic_form",
    "doc": "Implements a quadratic form on binary variables encoded in qubit registers.\n\n    A quadratic form on binary variables is a quadratic function :math:`Q` acting on a binary\n    variable of :math:`n` bits, :math:`x = x_0 ... x_{n-1}`. For an integer matrix :math:`A`,\n    an integer vector :math:`b` and an integer :math:`c` the function can be written as\n\n    .. math::\n\n        Q(x) = x^T A x + x^T b + c\n\n    If :math:`A`, :math:`b` or :math:`c` contain scalar values, this circuit computes only\n    an approximation of the quadratic form.\n\n    Provided with :math:`m` qubits to encode the value, this circuit computes :math:`Q(x) \\mod 2^m`\n    in [two's complement](https://stackoverflow.com/questions/1049722/what-is-2s-complement)\n    representation.\n\n    .. math::\n\n        |x\\rangle_n |0\\rangle_m \\mapsto |x\\rangle_n |(Q(x) + 2^m) \\mod 2^m \\rangle_m\n\n    Since we use two's complement e.g. the value of :math:`Q(x) = 3` requires 2 bits to represent\n    the value and 1 bit for the sign: `3 = '011'` where the first `0` indicates a positive value.\n    On the other hand, :math:`Q(x) = -3` would be `-3 = '101'`, where the first `1` indicates\n    a negative value and `01` is the two's complement of `3`.\n\n    If the value of :math:`Q(x)` is too large to be represented with `m` qubits, the resulting\n    bitstring is :math:`(Q(x) + 2^m) \\mod 2^m)`.\n\n    The implementation of this circuit is discussed in [1], Fig. 6.\n\n    References:\n\n    [1] Gilliam et al., Grover Adaptive Search for Constrained Polynomial Binary Optimization.\n    `arXiv:1912.04088 <https://arxiv.org/pdf/1912.04088.pdf>`_\n\n    ",
    "parameters": {
      "num_result_qubits": {
        "default": null,
        "annotation": "Optional[int]"
      },
      "quadratic": {
        "default": null,
        "annotation": "Optional[Union[np.ndarray, List[List[Union[float, ParameterExpression]]]]]"
      },
      "linear": {
        "default": null,
        "annotation": "Optional[Union[np.ndarray, List[Union[float, ParameterExpression]]]]"
      },
      "offset": {
        "default": null,
        "annotation": "Optional[Union[float, ParameterExpression]]"
      },
      "little_endian": {
        "default": true,
        "annotation": "bool"
      }
    }
  },
  {
    "class_name": "QuantumVolume",
    "module": "qiskit.circuit.library.quantum_volume",
    "doc": "A quantum volume model circuit.\n\n    The model circuits are random instances of circuits used to measure\n    the Quantum Volume metric, as introduced in [1].\n\n    The model circuits consist of layers of Haar random\n    elements of SU(4) applied between corresponding pairs\n    of qubits in a random bipartition.\n\n    Reference Circuit:\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import QuantumVolume\n       circuit = QuantumVolume(5, 6, seed=10)\n       circuit.draw('mpl')\n\n    Expanded Circuit:\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import QuantumVolume\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       circuit = QuantumVolume(5, 6, seed=10, classical_permutation=False)\n       _generate_circuit_library_visualization(circuit.decompose())\n\n    References:\n\n    [1] A. Cross et al. Validating quantum computers using\n    randomized model circuits, Phys. Rev. A 100, 032328 (2019).\n    `arXiv:1811.12926 <https://arxiv.org/abs/1811.12926>`__\n    ",
    "parameters": {
      "num_qubits": {
        "default": null,
        "annotation": "int"
      },
      "depth": {
        "default": null,
        "annotation": "Optional[int]"
      },
      "seed": {
        "default": null,
        "annotation": "Optional[Union[int, np.random.Generator]]"
      },
      "classical_permutation": {
        "default": true,
        "annotation": "bool"
      },
      "flatten": {
        "default": false,
        "annotation": "bool"
      }
    }
  },
  {
    "class_name": "RGQFTMultiplier",
    "module": "qiskit.circuit.library.arithmetic.multipliers.rg_qft_multiplier",
    "doc": "A QFT multiplication circuit to store product of two input registers out-of-place.\n\n    Multiplication in this circuit is implemented using the procedure of Fig. 3 in [1], where\n    weighted sum rotations are implemented as given in Fig. 5 in [1]. QFT is used on the output\n    register and is followed by rotations controlled by input registers. The rotations\n    transform the state into the product of two input registers in QFT base, which is\n    reverted from QFT base using inverse QFT.\n    As an example, a circuit that performs a modular QFT multiplication on two 2-qubit\n    sized input registers with an output register of 2 qubits, is as follows:\n\n    .. code-block:: text\n\n          a_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                                                       \u2502       \u2502      \u2502      \u2502\n          a_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                        \u2502       \u2502       \u2502       \u2502      \u2502       \u2502      \u2502      \u2502\n          b_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                        \u2502       \u2502       \u2502       \u2502      \u2502       \u2502      \u2502      \u2502\n          b_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502P(4\u03c0)  \u2502       \u2502P(2\u03c0)  \u2502      \u2502P(2\u03c0)  \u2502      \u2502P(\u03c0)  \u2502       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        out_0: \u25240     \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25240      \u251c\n               \u2502  qft \u2502         \u2502P(2\u03c0)          \u2502P(\u03c0)          \u2502P(\u03c0)         \u2502P(\u03c0/2) \u2502  iqft \u2502\n        out_1: \u25241     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25241      \u251c\n               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    .. seealso::\n\n        The :class:`.MultiplierGate` objects represents a multiplication, like this circuit class,\n        but allows the compiler to select the optimal decomposition based on the context.\n        Specific implementations can be set via the :class:`.HLSConfig`, e.g. this circuit\n        can be chosen via ``Multiplier=[\"qft_r17\"]``.\n\n    References:\n\n    [1] Ruiz-Perez et al., Quantum arithmetic with the Quantum Fourier Transform, 2017.\n    `arXiv:1411.5949 <https://arxiv.org/pdf/1411.5949.pdf>`_\n\n    ",
    "parameters": {
      "num_state_qubits": {
        "default": null,
        "annotation": "<class 'int'>"
      },
      "num_result_qubits": {
        "default": null,
        "annotation": "typing.Optional[int]"
      },
      "name": {
        "default": "RGQFTMultiplier",
        "annotation": "<class 'str'>"
      }
    }
  },
  {
    "class_name": "RealAmplitudes",
    "module": "qiskit.circuit.library.n_local.real_amplitudes",
    "doc": "The real-amplitudes 2-local circuit.\n\n    The ``RealAmplitudes`` circuit is a heuristic trial wave function used as Ansatz in chemistry\n    applications or classification circuits in machine learning. The circuit consists of\n    alternating layers of :math:`Y` rotations and :math:`CX` entanglements. The entanglement\n    pattern can be user-defined or selected from a predefined set.\n    It is called ``RealAmplitudes`` since the prepared quantum states will only have\n    real amplitudes, the complex part is always 0.\n\n    For example a ``RealAmplitudes`` circuit with 2 repetitions on 3 qubits with ``'reverse_linear'``\n    entanglement is\n\n    .. code-block:: text\n\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591            \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591            \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2524 Ry(\u03b8[0]) \u251c\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2591\u2500\u2524 Ry(\u03b8[3]) \u251c\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2591\u2500\u2524 Ry(\u03b8[6]) \u251c\n         \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591      \u250c\u2500\u2534\u2500\u2510 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591      \u250c\u2500\u2534\u2500\u2510 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n         \u2524 Ry(\u03b8[1]) \u251c\u2500\u2591\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2591\u2500\u2524 Ry(\u03b8[4]) \u251c\u2500\u2591\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2591\u2500\u2524 Ry(\u03b8[7]) \u251c\n         \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n         \u2524 Ry(\u03b8[2]) \u251c\u2500\u2591\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Ry(\u03b8[5]) \u251c\u2500\u2591\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Ry(\u03b8[8]) \u251c\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2518      \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2518      \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    The entanglement can be set using the ``entanglement`` keyword as string or a list of\n    index-pairs. See the documentation of :class:`~qiskit.circuit.library.TwoLocal` and\n    :class:`~qiskit.circuit.NLocal` for more detail. Additional options that can be set include the\n    number of repetitions, skipping rotation gates on qubits that are not entangled, leaving out\n    the final rotation layer and inserting barriers in between the rotation and entanglement\n    layers.\n\n    If some qubits are not entangled with other qubits it makes sense to not apply rotation gates\n    on these qubits, since a sequence of :math:`Y` rotations can be reduced to a single :math:`Y`\n    rotation with summed rotation angles.\n\n    Examples:\n\n        >>> ansatz = RealAmplitudes(3, reps=2)  # create the circuit on 3 qubits\n        >>> print(ansatz.decompose())\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 Ry(\u03b8[0]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Ry(\u03b8[3]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Ry(\u03b8[6]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524        \u250c\u2500\u2534\u2500\u2510    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524        \u250c\u2500\u2534\u2500\u2510    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_1: \u2524 Ry(\u03b8[1]) \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2524 Ry(\u03b8[4]) \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2524 Ry(\u03b8[7]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        q_2: \u2524 Ry(\u03b8[2]) \u251c\u2524 X \u251c\u2524 Ry(\u03b8[5]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2524 Ry(\u03b8[8]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> ansatz = RealAmplitudes(3, entanglement='full', reps=2, flatten=True)\n        >>> print(ansatz)\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 RY(\u03b8[0]) \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 RY(\u03b8[3]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 RY(\u03b8[6]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u250c\u2500\u2534\u2500\u2510  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_1: \u2524 RY(\u03b8[1]) \u251c\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 RY(\u03b8[4]) \u251c\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 RY(\u03b8[7]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510   \u250c\u2500\u2534\u2500\u2510    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510   \u250c\u2500\u2534\u2500\u2510    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_2: \u2524 RY(\u03b8[2]) \u251c\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2524 RY(\u03b8[5]) \u251c\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2524 RY(\u03b8[8]) \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> ansatz = RealAmplitudes(3, entanglement='linear', reps=2, insert_barriers=True,\n        ... flatten=True)\n        >>> qc = QuantumCircuit(3)  # create a circuit and append the RY variational form\n        >>> qc.compose(ansatz, inplace=True)\n        >>> qc.draw()\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591            \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591            \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 RY(\u03b8[0]) \u251c\u2500\u2591\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 RY(\u03b8[3]) \u251c\u2500\u2591\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 RY(\u03b8[6]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u250c\u2500\u2534\u2500\u2510      \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u250c\u2500\u2534\u2500\u2510      \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_1: \u2524 RY(\u03b8[1]) \u251c\u2500\u2591\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2591\u2500\u2524 RY(\u03b8[4]) \u251c\u2500\u2591\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2591\u2500\u2524 RY(\u03b8[7]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_2: \u2524 RY(\u03b8[2]) \u251c\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2591\u2500\u2524 RY(\u03b8[5]) \u251c\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2591\u2500\u2524 RY(\u03b8[8]) \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591      \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591      \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> ansatz = RealAmplitudes(4, reps=1, entanglement='circular', insert_barriers=True,\n        ... flatten=True)\n        >>> print(ansatz)\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2500\u2500\u2510                \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 RY(\u03b8[0]) \u251c\u2500\u2591\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 RY(\u03b8[4]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2534\u2500\u2510           \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_1: \u2524 RY(\u03b8[1]) \u251c\u2500\u2591\u2500\u2500\u2500\u253c\u2500\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 RY(\u03b8[5]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591   \u2502  \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510      \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_2: \u2524 RY(\u03b8[2]) \u251c\u2500\u2591\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2591\u2500\u2524 RY(\u03b8[6]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591   \u2502       \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_3: \u2524 RY(\u03b8[3]) \u251c\u2500\u2591\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2591\u2500\u2524 RY(\u03b8[7]) \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591                \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> ansatz = RealAmplitudes(4, reps=2, entanglement=[[0,3], [0,2]],\n        ... skip_unentangled_qubits=True, flatten=True)\n        >>> print(ansatz)\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 RY(\u03b8[0]) \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 RY(\u03b8[3]) \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 RY(\u03b8[6]) \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502       \u2502      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502       \u2502      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502     \u250c\u2500\u2534\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502     \u250c\u2500\u2534\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_2: \u2524 RY(\u03b8[1]) \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2524 RY(\u03b8[4]) \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2524 RY(\u03b8[7]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        q_3: \u2524 RY(\u03b8[2]) \u251c\u2524 X \u251c\u2524 RY(\u03b8[5]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2524 RY(\u03b8[8]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    .. seealso::\n\n        The :func:`.real_amplitudes` function constructs a functionally equivalent circuit, but faster.\n\n    ",
    "parameters": {
      "num_qubits": {
        "default": null,
        "annotation": "int | None"
      },
      "entanglement": {
        "default": "reverse_linear",
        "annotation": "str | list[list[int]] | Callable[[int], list[int]]"
      },
      "reps": {
        "default": 3,
        "annotation": "int"
      },
      "skip_unentangled_qubits": {
        "default": false,
        "annotation": "bool"
      },
      "skip_final_rotation_layer": {
        "default": false,
        "annotation": "bool"
      },
      "parameter_prefix": {
        "default": "\u03b8",
        "annotation": "str"
      },
      "insert_barriers": {
        "default": false,
        "annotation": "bool"
      },
      "initial_state": {
        "default": null,
        "annotation": "QuantumCircuit | None"
      },
      "name": {
        "default": "RealAmplitudes",
        "annotation": "str"
      },
      "flatten": {
        "default": null,
        "annotation": "bool | None"
      }
    }
  },
  {
    "class_name": "TwoLocal",
    "module": "qiskit.circuit.library.n_local.two_local",
    "doc": "The two-local circuit.\n\n    The two-local circuit is a parameterized circuit consisting of alternating rotation layers and\n    entanglement layers. The rotation layers are single qubit gates applied on all qubits.\n    The entanglement layer uses two-qubit gates to entangle the qubits according to a strategy set\n    using ``entanglement``. Both the rotation and entanglement gates can be specified as\n    string (e.g. ``'ry'`` or ``'cx'``), as gate-type (e.g. ``RYGate`` or ``CXGate``) or\n    as QuantumCircuit (e.g. a 1-qubit circuit or 2-qubit circuit).\n\n    A set of default entanglement strategies is provided:\n\n    * ``'full'`` entanglement is each qubit is entangled with all the others.\n    * ``'linear'`` entanglement is qubit :math:`i` entangled with qubit :math:`i + 1`,\n      for all :math:`i \\in \\{0, 1, ... , n - 2\\}`, where :math:`n` is the total number of qubits.\n    * ``'reverse_linear'`` entanglement is qubit :math:`i` entangled with qubit :math:`i + 1`,\n      for all :math:`i \\in \\{n-2, n-3, ... , 1, 0\\}`, where :math:`n` is the total number of qubits.\n      Note that if ``entanglement_blocks = 'cx'`` then this option provides the same unitary as\n      ``'full'`` with fewer entangling gates.\n    * ``'pairwise'`` entanglement is one layer where qubit :math:`i` is entangled with qubit\n      :math:`i + 1`, for all even values of :math:`i`, and then a second layer where qubit :math:`i`\n      is entangled with qubit :math:`i + 1`, for all odd values of :math:`i`.\n    * ``'circular'`` entanglement is linear entanglement but with an additional entanglement of the\n      first and last qubit before the linear part.\n    * ``'sca'`` (shifted-circular-alternating) entanglement is a generalized and modified version\n      of the proposed circuit 14 in `Sim et al. <https://arxiv.org/abs/1905.10876>`__.\n      It consists of circular entanglement where the 'long' entanglement connecting the first with\n      the last qubit is shifted by one each block.  Furthermore the role of control and target\n      qubits are swapped every block (therefore alternating).\n\n    The entanglement can further be specified using an entangler map, which is a list of index\n    pairs, such as\n\n    >>> entangler_map = [(0, 1), (1, 2), (2, 0)]\n\n    If different entanglements per block should be used, provide a list of entangler maps.\n    See the examples below on how this can be used.\n\n    >>> entanglement = [entangler_map_layer_1, entangler_map_layer_2, ... ]\n\n    Barriers can be inserted in between the different layers for better visualization using the\n    ``insert_barriers`` attribute.\n\n    For each parameterized gate a new parameter is generated using a\n    :class:`~qiskit.circuit.library.ParameterVector`. The name of these parameters can be chosen\n    using the ``parameter_prefix``.\n\n    Examples:\n\n        >>> two = TwoLocal(3, 'ry', 'cx', 'linear', reps=2, insert_barriers=True)\n        >>> print(two.decompose())  # decompose the layers into standard gates\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591            \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591            \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 Ry(\u03b8[0]) \u251c\u2500\u2591\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Ry(\u03b8[3]) \u251c\u2500\u2591\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Ry(\u03b8[6]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u250c\u2500\u2534\u2500\u2510      \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u250c\u2500\u2534\u2500\u2510      \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_1: \u2524 Ry(\u03b8[1]) \u251c\u2500\u2591\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2591\u2500\u2524 Ry(\u03b8[4]) \u251c\u2500\u2591\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2591\u2500\u2524 Ry(\u03b8[7]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_2: \u2524 Ry(\u03b8[2]) \u251c\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2591\u2500\u2524 Ry(\u03b8[5]) \u251c\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2591\u2500\u2524 Ry(\u03b8[8]) \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591      \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591      \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> two = TwoLocal(3, ['ry','rz'], 'cz', 'full', reps=1, insert_barriers=True, flatten=True)\n        >>> qc = QuantumCircuit(3)\n        >>> qc &= two\n        >>> print(qc.draw())\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591           \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 Ry(\u03b8[0]) \u251c\u2524 Rz(\u03b8[3]) \u251c\u2500\u2591\u2500\u2500\u25a0\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Ry(\u03b8[6]) \u251c\u2500\u2524 Rz(\u03b8[9]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591  \u2502  \u2502     \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u250c\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_1: \u2524 Ry(\u03b8[1]) \u251c\u2524 Rz(\u03b8[4]) \u251c\u2500\u2591\u2500\u2500\u25a0\u2500\u2500\u253c\u2500\u2500\u25a0\u2500\u2500\u2591\u2500\u2524 Ry(\u03b8[7]) \u251c\u2524 Rz(\u03b8[10]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591     \u2502  \u2502  \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_2: \u2524 Ry(\u03b8[2]) \u251c\u2524 Rz(\u03b8[5]) \u251c\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u25a0\u2500\u2500\u2591\u2500\u2524 Ry(\u03b8[8]) \u251c\u2524 Rz(\u03b8[11]) \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591           \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> entangler_map = [[0, 1], [1, 2], [2, 0]]  # circular entanglement for 3 qubits\n        >>> two = TwoLocal(3, 'x', 'crx', entangler_map, reps=1, flatten=True)\n        >>> print(two)  # note: no barriers inserted this time!\n                \u250c\u2500\u2500\u2500\u2510                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\n        q_0: |0>\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Rx(\u03b8[2]) \u251c\u2524 X \u251c\n                \u251c\u2500\u2500\u2500\u2524\u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2510\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\n        q_1: |0>\u2524 X \u251c\u2524 Rx(\u03b8[0]) \u251c\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                \u251c\u2500\u2500\u2500\u2524\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2500\u2500\u2500\u2518      \u2502     \u250c\u2500\u2500\u2500\u2510\n        q_2: |0>\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Rx(\u03b8[1]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\n                \u2514\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2514\u2500\u2500\u2500\u2518\n\n        >>> entangler_map = [[0, 3], [0, 2]]  # entangle the first and last two-way\n        >>> two = TwoLocal(4, [], 'cry', entangler_map, reps=1, flatten=True)\n        >>> circuit = two.compose(two)\n        >>> print(circuit.draw())  # note, that the parameters are the same!\n        q_0: \u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\n                  \u2502           \u2502           \u2502           \u2502\n        q_1: \u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\n                  \u2502      \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510     \u2502      \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\n        q_2: \u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Ry(\u03b8[1]) \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Ry(\u03b8[1]) \u251c\n             \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        q_3: \u2524 Ry(\u03b8[0]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Ry(\u03b8[0]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> layer_1 = [(0, 1), (0, 2)]\n        >>> layer_2 = [(1, 2)]\n        >>> two = TwoLocal(3, 'x', 'cx', [layer_1, layer_2], reps=2, insert_barriers=True,\n        ... flatten=True)\n        >>> print(two)\n             \u250c\u2500\u2500\u2500\u2510 \u2591            \u2591 \u250c\u2500\u2500\u2500\u2510 \u2591       \u2591 \u250c\u2500\u2500\u2500\u2510\n        q_0: \u2524 X \u251c\u2500\u2591\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2591\u2500\u2524 X \u251c\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 X \u251c\n             \u251c\u2500\u2500\u2500\u2524 \u2591 \u250c\u2500\u2534\u2500\u2510  \u2502   \u2591 \u251c\u2500\u2500\u2500\u2524 \u2591       \u2591 \u251c\u2500\u2500\u2500\u2524\n        q_1: \u2524 X \u251c\u2500\u2591\u2500\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2591\u2500\u2524 X \u251c\u2500\u2591\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2591\u2500\u2524 X \u251c\n             \u251c\u2500\u2500\u2500\u2524 \u2591 \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510 \u2591 \u251c\u2500\u2500\u2500\u2524 \u2591 \u250c\u2500\u2534\u2500\u2510 \u2591 \u251c\u2500\u2500\u2500\u2524\n        q_2: \u2524 X \u251c\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2591\u2500\u2524 X \u251c\u2500\u2591\u2500\u2524 X \u251c\u2500\u2591\u2500\u2524 X \u251c\n             \u2514\u2500\u2500\u2500\u2518 \u2591      \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2518\n\n    ",
    "parameters": {
      "num_qubits": {
        "default": null,
        "annotation": "int | None"
      },
      "rotation_blocks": {
        "default": null,
        "annotation": "str | type | qiskit.circuit.Instruction | QuantumCircuit | list[str | type | qiskit.circuit.Instruction | QuantumCircuit] | None"
      },
      "entanglement_blocks": {
        "default": null,
        "annotation": "str | type | qiskit.circuit.Instruction | QuantumCircuit | list[str | type | qiskit.circuit.Instruction | QuantumCircuit] | None"
      },
      "entanglement": {
        "default": "full",
        "annotation": "str | list[list[int]] | Callable[[int], list[int]]"
      },
      "reps": {
        "default": 3,
        "annotation": "int"
      },
      "skip_unentangled_qubits": {
        "default": false,
        "annotation": "bool"
      },
      "skip_final_rotation_layer": {
        "default": false,
        "annotation": "bool"
      },
      "parameter_prefix": {
        "default": "\u03b8",
        "annotation": "str"
      },
      "insert_barriers": {
        "default": false,
        "annotation": "bool"
      },
      "initial_state": {
        "default": null,
        "annotation": "QuantumCircuit | None"
      },
      "name": {
        "default": "TwoLocal",
        "annotation": "str"
      },
      "flatten": {
        "default": null,
        "annotation": "bool | None"
      }
    }
  },
  {
    "class_name": "UnitaryOverlap",
    "module": "qiskit.circuit.library.overlap",
    "doc": "Circuit that returns the overlap between two unitaries :math:`U_2^{\\dag} U_1`.\n\n    The input quantum circuits must represent unitary operations, since they must be invertible.\n    If the inputs will have parameters, they are replaced by :class:`.ParameterVector`\\s with\n    names `\"p1\"` (for circuit ``unitary1``) and `\"p2\"` (for circuit ``unitary_2``) in the output\n    circuit.\n\n    This circuit is usually employed in computing the fidelity:\n\n    .. math::\n\n        \\left|\\langle 0| U_2^{\\dag} U_1|0\\rangle\\right|^{2}\n\n    by computing the probability of being in the all-zeros bit-string, or equivalently,\n    the expectation value of projector :math:`|0\\rangle\\langle 0|`.\n\n    Example::\n\n        import numpy as np\n        from qiskit.circuit.library import EfficientSU2, UnitaryOverlap\n        from qiskit.primitives import Sampler\n\n        # get two circuit to prepare states of which we compute the overlap\n        circuit = EfficientSU2(2, reps=1)\n        unitary1 = circuit.assign_parameters(np.random.random(circuit.num_parameters))\n        unitary2 = circuit.assign_parameters(np.random.random(circuit.num_parameters))\n\n        # create the overlap circuit\n        overlap = UnitaryOverlap(unitary1, unitary2)\n\n        # sample from the overlap\n        sampler = Sampler(options={\"shots\": 100})\n        result = sampler.run(overlap).result()\n\n        # the fidelity is the probability to measure 0\n        fidelity = result.quasi_dists[0].get(0, 0)\n\n    ",
    "parameters": {
      "unitary1": {
        "default": null,
        "annotation": "<class 'qiskit.circuit.quantumcircuit.QuantumCircuit'>"
      },
      "unitary2": {
        "default": null,
        "annotation": "<class 'qiskit.circuit.quantumcircuit.QuantumCircuit'>"
      },
      "prefix1": {
        "default": "p1",
        "annotation": "<class 'str'>"
      },
      "prefix2": {
        "default": "p2",
        "annotation": "<class 'str'>"
      },
      "insert_barrier": {
        "default": false,
        "annotation": "<class 'bool'>"
      }
    }
  },
  {
    "class_name": "VBERippleCarryAdder",
    "module": "qiskit.circuit.library.arithmetic.adders.vbe_ripple_carry_adder",
    "doc": "The VBE ripple carry adder [1].\n\n    This circuit performs inplace addition of two equally-sized quantum registers.\n    As an example, a classical adder circuit that performs full addition (i.e. including\n    a carry-in bit) on two 2-qubit sized registers is as follows:\n\n    .. code-block:: text\n\n                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n           cin_0: \u25240       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25240          \u251c\u25240     \u251c\n                  \u2502        \u2502                       \u2502           \u2502\u2502      \u2502\n             a_0: \u25241       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25241          \u251c\u25241     \u251c\n                  \u2502        \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502           \u2502\u2502  Sum \u2502\n             a_1: \u2524        \u251c\u25241       \u251c\u2500\u2500\u25a0\u2500\u2500\u25241     \u251c\u2524           \u251c\u2524      \u251c\n                  \u2502        \u2502\u2502        \u2502  \u2502  \u2502      \u2502\u2502           \u2502\u2502      \u2502\n             b_0: \u25242 Carry \u251c\u2524        \u251c\u2500\u2500\u253c\u2500\u2500\u2524      \u251c\u25242 Carry_dg \u251c\u25242     \u251c\n                  \u2502        \u2502\u2502        \u2502\u250c\u2500\u2534\u2500\u2510\u2502      \u2502\u2502           \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             b_1: \u2524        \u251c\u25242 Carry \u251c\u2524 X \u251c\u25242 Sum \u251c\u2524           \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                  \u2502        \u2502\u2502        \u2502\u2514\u2500\u2500\u2500\u2518\u2502      \u2502\u2502           \u2502\n          cout_0: \u2524        \u251c\u25243       \u251c\u2500\u2500\u2500\u2500\u2500\u2524      \u251c\u2524           \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                  \u2502        \u2502\u2502        \u2502     \u2502      \u2502\u2502           \u2502\n        helper_0: \u25243       \u251c\u25240       \u251c\u2500\u2500\u2500\u2500\u2500\u25240     \u251c\u25243          \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\n    Here *Carry* and *Sum* gates correspond to the gates introduced in [1].\n    *Carry_dg* correspond to the inverse of the *Carry* gate. Note that\n    in this implementation the input register qubits are ordered as all qubits from\n    the first input register, followed by all qubits from the second input register.\n    This is different ordering as compared to Figure 2 in [1], which leads to a different\n    drawing of the circuit.\n\n    .. seealso::\n\n        The following generic gate objects perform additions, like this circuit class,\n        but allow the compiler to select the optimal decomposition based on the context.\n        Specific implementations can be set via the :class:`.HLSConfig`, e.g. this circuit\n        can be chosen via ``Adder=[\"ripple_v95\"]``.\n\n        :class:`.ModularAdderGate`: A generic inplace adder, modulo :math:`2^n`. This\n            is functionally equivalent to ``kind=\"fixed\"``.\n\n        :class:`.AdderGate`: A generic inplace adder. This\n            is functionally equivalent to ``kind=\"half\"``.\n\n        :class:`.FullAdderGate`: A generic inplace adder, with a carry-in bit. This\n            is functionally equivalent to ``kind=\"full\"``.\n\n    References:\n\n    [1] Vedral et al., Quantum Networks for Elementary Arithmetic Operations, 1995.\n    `arXiv:quant-ph/9511018 <https://arxiv.org/pdf/quant-ph/9511018.pdf>`_\n\n    ",
    "parameters": {
      "num_state_qubits": {
        "default": null,
        "annotation": "int"
      },
      "kind": {
        "default": "full",
        "annotation": "str"
      },
      "name": {
        "default": "VBERippleCarryAdder",
        "annotation": "str"
      }
    }
  },
  {
    "class_name": "XOR",
    "module": "qiskit.circuit.library.boolean_logic.quantum_xor",
    "doc": "An n_qubit circuit for bitwise xor-ing the input with some integer ``amount``.\n\n    The ``amount`` is xor-ed in bitstring form with the input.\n\n    This circuit can also represent addition by ``amount`` over the finite field GF(2).\n    ",
    "parameters": {
      "num_qubits": {
        "default": null,
        "annotation": "<class 'int'>"
      },
      "amount": {
        "default": null,
        "annotation": "typing.Optional[int]"
      },
      "seed": {
        "default": null,
        "annotation": "typing.Optional[int]"
      }
    }
  },
  {
    "class_name": "ZFeatureMap",
    "module": "qiskit.circuit.library.data_preparation._z_feature_map",
    "doc": "The first order Pauli Z-evolution circuit.\n\n    On 3 qubits and with 2 repetitions the circuit is represented by:\n\n    .. code-block:: text\n\n        \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2524 H \u251c\u2524 P(2.0*x[0]) \u251c\u2524 H \u251c\u2524 P(2.0*x[0]) \u251c\n        \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2524 H \u251c\u2524 U(2.0*x[1]) \u251c\u2524 H \u251c\u2524 P(2.0*x[1]) \u251c\n        \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2524 H \u251c\u2524 P(2.0*x[2]) \u251c\u2524 H \u251c\u2524 P(2.0*x[2]) \u251c\n        \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    This is a sub-class of :class:`~qiskit.circuit.library.PauliFeatureMap` where the Pauli\n    strings are fixed as `['Z']`. As a result the first order expansion will be a circuit without\n    entangling gates.\n\n    Examples:\n\n        >>> prep = ZFeatureMap(3, reps=3, insert_barriers=True)\n        >>> print(prep.decompose())\n             \u250c\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 H \u251c\u2500\u2591\u2500\u2524 P(2.0*x[0]) \u251c\u2500\u2591\u2500\u2524 H \u251c\u2500\u2591\u2500\u2524 P(2.0*x[0]) \u251c\u2500\u2591\u2500\u2524 H \u251c\u2500\u2591\u2500\u2524 P(2.0*x[0]) \u251c\n             \u251c\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_1: \u2524 H \u251c\u2500\u2591\u2500\u2524 P(2.0*x[1]) \u251c\u2500\u2591\u2500\u2524 H \u251c\u2500\u2591\u2500\u2524 P(2.0*x[1]) \u251c\u2500\u2591\u2500\u2524 H \u251c\u2500\u2591\u2500\u2524 P(2.0*x[1]) \u251c\n             \u251c\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_2: \u2524 H \u251c\u2500\u2591\u2500\u2524 P(2.0*x[2]) \u251c\u2500\u2591\u2500\u2524 H \u251c\u2500\u2591\u2500\u2524 P(2.0*x[2]) \u251c\u2500\u2591\u2500\u2524 H \u251c\u2500\u2591\u2500\u2524 P(2.0*x[2]) \u251c\n             \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> data_map = lambda x: x[0]*x[0] + 1  # note: input is an array\n        >>> prep = ZFeatureMap(3, reps=1, data_map_func=data_map)\n        >>> print(prep.decompose())\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 H \u251c\u2524 P(2.0*x[0]**2 + 2.0) \u251c\n             \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_1: \u2524 H \u251c\u2524 P(2.0*x[1]**2 + 2.0) \u251c\n             \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_2: \u2524 H \u251c\u2524 P(2.0*x[2]**2 + 2.0) \u251c\n             \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> from qiskit.circuit.library import TwoLocal\n        >>> ry = TwoLocal(3, \"ry\", \"cz\", reps=1)\n        >>> classifier = ZFeatureMap(3, reps=1) + ry\n        >>> print(classifier.decompose())\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 H \u251c\u2524 P(2.0*x[0]) \u251c\u2524 RY(\u03b8[0]) \u251c\u2500\u25a0\u2500\u2500\u25a0\u2500\u2524 RY(\u03b8[3]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502  \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_1: \u2524 H \u251c\u2524 P(2.0*x[1]) \u251c\u2524 RY(\u03b8[1]) \u251c\u2500\u25a0\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 RY(\u03b8[4]) \u251c\n             \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524    \u2502      \u2502      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_2: \u2524 H \u251c\u2524 P(2.0*x[2]) \u251c\u2524 RY(\u03b8[2]) \u251c\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 RY(\u03b8[5]) \u251c\n             \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    ",
    "parameters": {
      "feature_dimension": {
        "default": null,
        "annotation": "<class 'int'>"
      },
      "reps": {
        "default": 2,
        "annotation": "<class 'int'>"
      },
      "data_map_func": {
        "default": null,
        "annotation": "typing.Optional[typing.Callable[[numpy.ndarray], float]]"
      },
      "parameter_prefix": {
        "default": "x",
        "annotation": "<class 'str'>"
      },
      "insert_barriers": {
        "default": false,
        "annotation": "<class 'bool'>"
      },
      "name": {
        "default": "ZFeatureMap",
        "annotation": "<class 'str'>"
      }
    }
  },
  {
    "class_name": "ZZFeatureMap",
    "module": "qiskit.circuit.library.data_preparation._zz_feature_map",
    "doc": "Second-order Pauli-Z evolution circuit.\n\n    For 3 qubits and 1 repetition and linear entanglement the circuit is represented by:\n\n    .. code-block:: text\n\n        \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2524 H \u251c\u2524 P(2.0*\u03c6(x[0])) \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\n        \u2524 H \u251c\u2524 P(2.0*\u03c6(x[1])) \u251c\u2524 X \u251c\u2524 P(2.0*\u03c6(x[0],x[1])) \u251c\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\n        \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\n        \u2524 H \u251c\u2524 P(2.0*\u03c6(x[2])) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2524 P(2.0*\u03c6(x[1],x[2])) \u251c\u2524 X \u251c\n        \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                 \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\n\n    where :math:`\\varphi` is a classical non-linear function, which defaults to :math:`\\varphi(x) = x`\n    if and :math:`\\varphi(x,y) = (\\pi - x)(\\pi - y)`.\n\n    Examples:\n\n    .. code-block::\n\n         from qiskit.circuit.library import ZZFeatureMap\n         prep = ZZFeatureMap(2, reps=1)\n         print(prep.decompose())\n\n    .. code-block:: text\n\n              \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         q_0: \u2524 H \u251c\u2524 P(2.0*x[0]) \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\n              \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\n         q_1: \u2524 H \u251c\u2524 P(2.0*x[1]) \u251c\u2524 X \u251c\u2524 P(2.0*(pi - x[0])*(pi - x[1])) \u251c\u2524 X \u251c\n              \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\n\n    .. code-block::\n\n         from qiskit.circuit.library import EfficientSU2\n         classifier = ZZFeatureMap(3).compose(EfficientSU2(3))\n         classifier.num_parameters\n\n    .. code-block:: text\n\n         27\n\n    .. code-block::\n\n         classifier.parameters  # 'x' for the data preparation, '\u03b8' for the SU2 parameters\n\n    .. code-block:: text\n\n         ParameterView([\n             ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),\n             ParameterVectorElement(x[2]), ParameterVectorElement(\u03b8[0]),\n             ParameterVectorElement(\u03b8[1]), ParameterVectorElement(\u03b8[2]),\n             ParameterVectorElement(\u03b8[3]), ParameterVectorElement(\u03b8[4]),\n             ParameterVectorElement(\u03b8[5]), ParameterVectorElement(\u03b8[6]),\n             ParameterVectorElement(\u03b8[7]), ParameterVectorElement(\u03b8[8]),\n             ParameterVectorElement(\u03b8[9]), ParameterVectorElement(\u03b8[10]),\n             ParameterVectorElement(\u03b8[11]), ParameterVectorElement(\u03b8[12]),\n             ParameterVectorElement(\u03b8[13]), ParameterVectorElement(\u03b8[14]),\n             ParameterVectorElement(\u03b8[15]), ParameterVectorElement(\u03b8[16]),\n             ParameterVectorElement(\u03b8[17]), ParameterVectorElement(\u03b8[18]),\n             ParameterVectorElement(\u03b8[19]), ParameterVectorElement(\u03b8[20]),\n             ParameterVectorElement(\u03b8[21]), ParameterVectorElement(\u03b8[22]),\n             ParameterVectorElement(\u03b8[23])\n         ])\n\n    .. code-block::\n\n         classifier.count_ops()\n\n    .. code-block:: text\n\n        OrderedDict([('ZZFeatureMap', 1), ('EfficientSU2', 1)])\n\n    ",
    "parameters": {
      "feature_dimension": {
        "default": null,
        "annotation": "<class 'int'>"
      },
      "reps": {
        "default": 2,
        "annotation": "<class 'int'>"
      },
      "entanglement": {
        "default": "full",
        "annotation": "typing.Union[str, typing.Dict[int, typing.List[typing.Tuple[int]]], typing.Callable[[int], typing.Union[str, typing.Dict[int, typing.List[typing.Tuple[int]]]]]]"
      },
      "data_map_func": {
        "default": null,
        "annotation": "typing.Optional[typing.Callable[[numpy.ndarray], float]]"
      },
      "parameter_prefix": {
        "default": "x",
        "annotation": "<class 'str'>"
      },
      "insert_barriers": {
        "default": false,
        "annotation": "<class 'bool'>"
      },
      "name": {
        "default": "ZZFeatureMap",
        "annotation": "<class 'str'>"
      }
    }
  },
  {
    "class_name": "CDKMRippleCarryAdder",
    "module": "qiskit.circuit.library.arithmetic.adders.cdkm_ripple_carry_adder",
    "doc": "A ripple-carry circuit to perform in-place addition on two qubit registers.\n\n    As an example, a ripple-carry adder circuit that performs addition on two 3-qubit sized\n    registers with a carry-in bit (``kind=\"full\"``) is as follows:\n\n    .. code-block:: text\n\n                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         cin_0: \u25242     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25242     \u251c\n                \u2502      \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502      \u2502\n           a_0: \u25240     \u251c\u25242     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25242     \u251c\u25240     \u251c\n                \u2502      \u2502\u2502      \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502      \u2502\u2502      \u2502\n           a_1: \u2524  MAJ \u251c\u25240     \u251c\u25242     \u251c\u2500\u2500\u2500\u2500\u2500\u25242     \u251c\u25240     \u251c\u2524  UMA \u251c\n                \u2502      \u2502\u2502      \u2502\u2502      \u2502     \u2502      \u2502\u2502      \u2502\u2502      \u2502\n           a_2: \u2524      \u251c\u2524  MAJ \u251c\u25240     \u251c\u2500\u2500\u25a0\u2500\u2500\u25240     \u251c\u2524  UMA \u251c\u2524      \u251c\n                \u2502      \u2502\u2502      \u2502\u2502      \u2502  \u2502  \u2502      \u2502\u2502      \u2502\u2502      \u2502\n           b_0: \u25241     \u251c\u2524      \u251c\u2524  MAJ \u251c\u2500\u2500\u253c\u2500\u2500\u2524  UMA \u251c\u2524      \u251c\u25241     \u251c\n                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502      \u2502\u2502      \u2502  \u2502  \u2502      \u2502\u2502      \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           b_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25241     \u251c\u2524      \u251c\u2500\u2500\u253c\u2500\u2500\u2524      \u251c\u25241     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502      \u2502  \u2502  \u2502      \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           b_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25241     \u251c\u2500\u2500\u253c\u2500\u2500\u25241     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        cout_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                                        \u2514\u2500\u2500\u2500\u2518\n\n    Here *MAJ* and *UMA* gates correspond to the gates introduced in [1]. Note that\n    in this implementation the input register qubits are ordered as all qubits from\n    the first input register, followed by all qubits from the second input register.\n\n    Two different kinds of adders are supported. By setting the ``kind`` argument, you can also\n    choose a half-adder, which doesn't have a carry-in, and a fixed-sized-adder, which has neither\n    carry-in nor carry-out, and thus acts on fixed register sizes. Unlike the full-adder,\n    these circuits need one additional helper qubit.\n\n    The circuit diagram for the fixed-point adder (``kind=\"fixed\"``) on 3-qubit sized inputs is\n\n    .. code-block:: text\n\n                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n           a_0: \u25240     \u251c\u25242     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25242     \u251c\u25240     \u251c\n                \u2502      \u2502\u2502      \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502      \u2502\u2502      \u2502\n           a_1: \u2524      \u251c\u25240     \u251c\u25242     \u251c\u25242     \u251c\u25240     \u251c\u2524      \u251c\n                \u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\n           a_2: \u2524      \u251c\u2524  MAJ \u251c\u25240     \u251c\u25240     \u251c\u2524  UMA \u251c\u2524      \u251c\n                \u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\n           b_0: \u25241 MAJ \u251c\u2524      \u251c\u2524  MAJ \u251c\u2524  UMA \u251c\u2524      \u251c\u25241 UMA \u251c\n                \u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\n           b_1: \u2524      \u251c\u25241     \u251c\u2524      \u251c\u2524      \u251c\u25241     \u251c\u2524      \u251c\n                \u2502      \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502      \u2502\u2502      \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502      \u2502\n           b_2: \u2524      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25241     \u251c\u25241     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524      \u251c\n                \u2502      \u2502        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502      \u2502\n        help_0: \u25242     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25242     \u251c\n                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    It has one less qubit than the full-adder since it doesn't have the carry-out, but uses\n    a helper qubit instead of the carry-in, so it only has one less qubit, not two.\n\n    .. seealso::\n\n        The following generic gate objects perform additions, like this circuit class,\n        but allow the compiler to select the optimal decomposition based on the context.\n        Specific implementations can be set via the :class:`.HLSConfig`, e.g. this circuit\n        can be chosen via ``Adder=[\"ripple_c04\"]``.\n\n        :class:`.ModularAdderGate`: A generic inplace adder, modulo :math:`2^n`. This\n            is functionally equivalent to ``kind=\"fixed\"``.\n\n        :class:`.AdderGate`: A generic inplace adder. This\n            is functionally equivalent to ``kind=\"half\"``.\n\n        :class:`.FullAdderGate`: A generic inplace adder, with a carry-in bit. This\n            is functionally equivalent to ``kind=\"full\"``.\n\n    References:\n\n    [1] Cuccaro et al., A new quantum ripple-carry addition circuit, 2004.\n    `arXiv:quant-ph/0410184 <https://arxiv.org/pdf/quant-ph/0410184.pdf>`_\n\n    [2] Vedral et al., Quantum Networks for Elementary Arithmetic Operations, 1995.\n    `arXiv:quant-ph/9511018 <https://arxiv.org/pdf/quant-ph/9511018.pdf>`_\n\n    ",
    "parameters": {
      "num_state_qubits": {
        "default": null,
        "annotation": "<class 'int'>"
      },
      "kind": {
        "default": "full",
        "annotation": "<class 'str'>"
      },
      "name": {
        "default": "CDKMRippleCarryAdder",
        "annotation": "<class 'str'>"
      }
    }
  },
  {
    "class_name": "DraperQFTAdder",
    "module": "qiskit.circuit.library.arithmetic.adders.draper_qft_adder",
    "doc": "A circuit that uses QFT to perform in-place addition on two qubit registers.\n\n    For registers with :math:`n` qubits, the QFT adder can perform addition modulo\n    :math:`2^n` (with ``kind=\"fixed\"``) or ordinary addition by adding a carry qubits (with\n    ``kind=\"half\"``).\n\n    As an example, a non-fixed_point QFT adder circuit that performs addition on two 2-qubit sized\n    registers is as follows:\n\n    .. code-block:: text\n\n         a_0:   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                         \u2502      \u2502                        \u2502\n         a_1:   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502P(\u03c0)  \u2502        \u2502      \u2502        \u2502       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         b_0:   \u25240     \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25240      \u251c\n                \u2502      \u2502        \u2502P(\u03c0/2)  \u2502P(\u03c0)  \u2502        \u2502       \u2502       \u2502\n         b_1:   \u25241 qft \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25241 iqft \u251c\n                \u2502      \u2502                        \u2502P(\u03c0/2)  \u2502P(\u03c0/4) \u2502       \u2502\n        cout_0: \u25242     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25242      \u251c\n                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    .. seealso::\n\n        The following generic gate objects perform additions, like this circuit class,\n        but allow the compiler to select the optimal decomposition based on the context.\n        Specific implementations can be set via the :class:`.HLSConfig`, e.g. this\n        circuit can be chosen via ``Adder=[\"qft_d00\"]``.\n\n        :class:`.ModularAdderGate`: A generic inplace adder, modulo :math:`2^n`. This\n            is functionally equivalent to ``kind=\"fixed\"``.\n\n        :class:`.AdderGate`: A generic inplace adder. This\n            is functionally equivalent to ``kind=\"half\"``.\n\n    References:\n\n    [1] T. G. Draper, Addition on a Quantum Computer, 2000.\n    `arXiv:quant-ph/0008033 <https://arxiv.org/pdf/quant-ph/0008033.pdf>`_\n\n    [2] Ruiz-Perez et al., Quantum arithmetic with the Quantum Fourier Transform, 2017.\n    `arXiv:1411.5949 <https://arxiv.org/pdf/1411.5949.pdf>`_\n\n    [3] Vedral et al., Quantum Networks for Elementary Arithmetic Operations, 1995.\n    `arXiv:quant-ph/9511018 <https://arxiv.org/pdf/quant-ph/9511018.pdf>`_\n\n    ",
    "parameters": {
      "num_state_qubits": {
        "default": null,
        "annotation": "<class 'int'>"
      },
      "kind": {
        "default": "fixed",
        "annotation": "<class 'str'>"
      },
      "name": {
        "default": "DraperQFTAdder",
        "annotation": "<class 'str'>"
      }
    }
  },
  {
    "class_name": "FunctionalPauliRotations",
    "module": "qiskit.circuit.library.arithmetic.functional_pauli_rotations",
    "doc": "Base class for functional Pauli rotations.",
    "parameters": {
      "num_state_qubits": {
        "default": null,
        "annotation": "typing.Optional[int]"
      },
      "basis": {
        "default": "Y",
        "annotation": "<class 'str'>"
      },
      "name": {
        "default": "F",
        "annotation": "<class 'str'>"
      }
    }
  },
  {
    "class_name": "HRSCumulativeMultiplier",
    "module": "qiskit.circuit.library.arithmetic.multipliers.hrs_cumulative_multiplier",
    "doc": "A multiplication circuit to store product of two input registers out-of-place.\n\n    Circuit uses the approach from [1]. As an example, a multiplier circuit that\n    performs a non-modular multiplication on two 3-qubit sized registers with\n    the default adder is as follows (where ``Adder`` denotes the\n    ``CDKMRippleCarryAdder``):\n\n    .. code-block:: text\n\n          a_0: \u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                   \u2502\n          a_1: \u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                   \u2502         \u2502\n          a_2: \u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\n               \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\n          b_0: \u25240       \u251c\u25240       \u251c\u25240       \u251c\n               \u2502        \u2502\u2502        \u2502\u2502        \u2502\n          b_1: \u25241       \u251c\u25241       \u251c\u25241       \u251c\n               \u2502        \u2502\u2502        \u2502\u2502        \u2502\n          b_2: \u25242       \u251c\u25242       \u251c\u25242       \u251c\n               \u2502        \u2502\u2502        \u2502\u2502        \u2502\n        out_0: \u25243       \u251c\u2524        \u251c\u2524        \u251c\n               \u2502        \u2502\u2502        \u2502\u2502        \u2502\n        out_1: \u25244       \u251c\u25243       \u251c\u2524        \u251c\n               \u2502  Adder \u2502\u2502  Adder \u2502\u2502  Adder \u2502\n        out_2: \u25245       \u251c\u25244       \u251c\u25243       \u251c\n               \u2502        \u2502\u2502        \u2502\u2502        \u2502\n        out_3: \u25246       \u251c\u25245       \u251c\u25244       \u251c\n               \u2502        \u2502\u2502        \u2502\u2502        \u2502\n        out_4: \u2524        \u251c\u25246       \u251c\u25245       \u251c\n               \u2502        \u2502\u2502        \u2502\u2502        \u2502\n        out_5: \u2524        \u251c\u2524        \u251c\u25246       \u251c\n               \u2502        \u2502\u2502        \u2502\u2502        \u2502\n        aux_0: \u25247       \u251c\u25247       \u251c\u25247       \u251c\n               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Multiplication in this circuit is implemented in a classical approach by performing\n    a series of shifted additions using one of the input registers while the qubits\n    from the other input register act as control qubits for the adders.\n\n    .. seealso::\n\n        The :class:`.MultiplierGate` objects represents a multiplication, like this circuit class,\n        but allows the compiler to select the optimal decomposition based on the context.\n        Specific implementations can be set via the :class:`.HLSConfig`, e.g. this circuit\n        can be chosen via ``Multiplier=[\"cumulative_h18\"]``.\n\n    References:\n\n    [1] H\u00e4ner et al., Optimizing Quantum Circuits for Arithmetic, 2018.\n    `arXiv:1805.12445 <https://arxiv.org/pdf/1805.12445.pdf>`_\n\n    ",
    "parameters": {
      "num_state_qubits": {
        "default": null,
        "annotation": "<class 'int'>"
      },
      "num_result_qubits": {
        "default": null,
        "annotation": "typing.Optional[int]"
      },
      "adder": {
        "default": null,
        "annotation": "typing.Optional[qiskit.circuit.quantumcircuit.QuantumCircuit]"
      },
      "name": {
        "default": "HRSCumulativeMultiplier",
        "annotation": "<class 'str'>"
      }
    }
  },
  {
    "class_name": "IntegerComparator",
    "module": "qiskit.circuit.library.arithmetic.integer_comparator",
    "doc": "Integer Comparator.\n\n    Operator compares basis states :math:`|i\\rangle_n` against a classically given integer\n    :math:`L` of fixed value and flips a target qubit if :math:`i \\geq L`\n    (or :math:`<` depending on the parameter ``geq``):\n\n    .. math::\n\n        |i\\rangle_n |0\\rangle \\mapsto |i\\rangle_n |i \\geq L\\rangle\n\n    This operation is based on two's complement implementation of binary subtraction but only\n    uses carry bits and no actual result bits. If the most significant carry bit\n    (the results bit) is 1, the :math:`\\geq` condition is ``True`` otherwise it is ``False``.\n    ",
    "parameters": {
      "num_state_qubits": {
        "default": null,
        "annotation": "int | None"
      },
      "value": {
        "default": null,
        "annotation": "int | None"
      },
      "geq": {
        "default": true,
        "annotation": "bool"
      },
      "name": {
        "default": "cmp",
        "annotation": "str"
      }
    }
  },
  {
    "class_name": "LinearPauliRotations",
    "module": "qiskit.circuit.library.arithmetic.linear_pauli_rotations",
    "doc": "Linearly-controlled X, Y or Z rotation.\n\n    For a register of state qubits :math:`|x\\rangle`, a target qubit :math:`|0\\rangle` and the\n    basis ``'Y'`` this circuit acts as:\n\n    .. code-block:: text\n\n            q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 ... \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                                          \u2502\n                                          .\n                                          \u2502\n        q_(n-1): \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 ... \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            q_n: \u2500\u2524 RY(offset) \u251c\u2500\u2500\u2524 RY(2^0 slope) \u251c  ...  \u2524 RY(2^(n-1) slope) \u251c\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    This can for example be used to approximate linear functions, with :math:`a =` ``slope``:math:`/2`\n    and :math:`b =` ``offset``:math:`/2` and the basis ``'Y'``:\n\n    .. math::\n\n        |x\\rangle |0\\rangle \\mapsto \\cos(ax + b)|x\\rangle|0\\rangle + \\sin(ax + b)|x\\rangle |1\\rangle\n\n    Since for small arguments :math:`\\sin(x) \\approx x` this operator can be used to approximate\n    linear functions.\n    ",
    "parameters": {
      "num_state_qubits": {
        "default": null,
        "annotation": "Optional[int]"
      },
      "slope": {
        "default": 1,
        "annotation": "float"
      },
      "offset": {
        "default": 0,
        "annotation": "float"
      },
      "basis": {
        "default": "Y",
        "annotation": "str"
      },
      "name": {
        "default": "LinRot",
        "annotation": "str"
      }
    }
  },
  {
    "class_name": "PiecewiseLinearPauliRotationsGate",
    "module": "qiskit.circuit.library.arithmetic.piecewise_linear_pauli_rotations",
    "doc": "Piecewise-linearly-controlled Pauli rotations.\n\n    For a piecewise linear (not necessarily continuous) function :math:`f(x)`, which is defined\n    through breakpoints, slopes and offsets as follows.\n    Suppose the breakpoints :math:`(x_0, ..., x_J)` are a subset of :math:`[0, 2^n-1]`, where\n    :math:`n` is the number of state qubits. Further on, denote the corresponding slopes and\n    offsets by :math:`a_j` and :math:`b_j` respectively.\n    Then f(x) is defined as:\n\n    .. math::\n\n        f(x) = \\begin{cases}\n            0, x < x_0 \\\\\n            a_j (x - x_j) + b_j, x_j \\leq x < x_{j+1}\n            \\end{cases}\n\n    where we implicitly assume :math:`x_{J+1} = 2^n`.\n    ",
    "parameters": {
      "num_state_qubits": {
        "default": null,
        "annotation": "int | None"
      },
      "breakpoints": {
        "default": null,
        "annotation": "list[int] | None"
      },
      "slopes": {
        "default": null,
        "annotation": "list[float] | np.ndarray | None"
      },
      "offsets": {
        "default": null,
        "annotation": "list[float] | np.ndarray | None"
      },
      "basis": {
        "default": "Y",
        "annotation": "str"
      },
      "name": {
        "default": "pw_lin",
        "annotation": "str"
      }
    }
  },
  {
    "class_name": "PiecewisePolynomialPauliRotationsGate",
    "module": "qiskit.circuit.library.arithmetic.piecewise_polynomial_pauli_rotations",
    "doc": "Piecewise-polynomially-controlled Pauli rotations.\n\n    This class implements a piecewise polynomial (not necessarily continuous) function,\n    :math:`f(x)`, on qubit amplitudes, which is defined through breakpoints and coefficients as\n    follows.\n    Suppose the breakpoints :math:`(x_0, ..., x_J)` are a subset of :math:`[0, 2^n-1]`, where\n    :math:`n` is the number of state qubits. Further on, denote the corresponding coefficients by\n    :math:`[a_{j,1},...,a_{j,d}]`, where :math:`d` is the highest degree among all polynomials.\n\n    Then :math:`f(x)` is defined as:\n\n    .. math::\n\n        f(x) = \\begin{cases}\n            0, x < x_0 \\\\\n            \\sum_{i=0}^{i=d}a_{j,i}/2 x^i, x_j \\leq x < x_{j+1}\n            \\end{cases}\n\n    where if given the same number of breakpoints as polynomials, we implicitly assume\n    :math:`x_{J+1} = 2^n`.\n\n    .. note::\n\n        Note the :math:`1/2` factor in the coefficients of :math:`f(x)`, this is consistent with\n        Qiskit's Pauli rotations.\n\n    Examples:\n\n        >>> from qiskit import QuantumCircuit\n        >>> from qiskit.circuit.library.arithmetic.piecewise_polynomial_pauli_rotations import\\\n        ... PiecewisePolynomialPauliRotations\n        >>> qubits, breakpoints, coeffs = (2, [0, 2], [[0, -1.2],[-1, 1, 3]])\n        >>> poly_r = PiecewisePolynomialPauliRotations(num_state_qubits=qubits,\n        ...breakpoints=breakpoints, coeffs=coeffs)\n        >>>\n        >>> qc = QuantumCircuit(poly_r.num_qubits)\n        >>> qc.h(list(range(qubits)));\n        >>> qc.append(poly_r.to_instruction(), list(range(qc.num_qubits)));\n        >>> qc.draw()\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 H \u251c\u25240         \u251c\n             \u251c\u2500\u2500\u2500\u2524\u2502          \u2502\n        q_1: \u2524 H \u251c\u25241         \u251c\n             \u2514\u2500\u2500\u2500\u2518\u2502          \u2502\n        q_2: \u2500\u2500\u2500\u2500\u2500\u25242         \u251c\n                  \u2502  pw_poly \u2502\n        q_3: \u2500\u2500\u2500\u2500\u2500\u25243         \u251c\n                  \u2502          \u2502\n        q_4: \u2500\u2500\u2500\u2500\u2500\u25244         \u251c\n                  \u2502          \u2502\n        q_5: \u2500\u2500\u2500\u2500\u2500\u25245         \u251c\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    References:\n\n    [1] Haener, T., Roetteler, M., & Svore, K. M. (2018).\n    Optimizing Quantum Circuits for Arithmetic.\n    `arXiv:1805.12445 <http://arxiv.org/abs/1805.12445>`_\n\n    [2] Carrera Vazquez, A., Hiptmair, R., & Woerner, S. (2022).\n    Enhancing the Quantum Linear Systems Algorithm using Richardson Extrapolation.\n    `ACM Transactions on Quantum Computing 3, 1, Article 2 <https://doi.org/10.1145/3490631>`_\n    ",
    "parameters": {
      "num_state_qubits": {
        "default": null,
        "annotation": "Optional[int]"
      },
      "breakpoints": {
        "default": null,
        "annotation": "Optional[List[int]]"
      },
      "coeffs": {
        "default": null,
        "annotation": "Optional[List[List[float]]]"
      },
      "basis": {
        "default": "Y",
        "annotation": "str"
      },
      "name": {
        "default": "pw_poly",
        "annotation": "str"
      }
    }
  },
  {
    "class_name": "PolynomialPauliRotations",
    "module": "qiskit.circuit.library.arithmetic.polynomial_pauli_rotations",
    "doc": "A circuit implementing polynomial Pauli rotations.\n\n    For a polynomial :math:`p(x)`, a basis state :math:`|i\\rangle` and a target qubit\n    :math:`|0\\rangle` this operator acts as:\n\n    .. math::\n\n        |i\\rangle |0\\rangle \\mapsto \\cos\\left(\\frac{p(i)}{2}\\right) |i\\rangle |0\\rangle\n        + \\sin\\left(\\frac{p(i)}{2}\\right) |i\\rangle |1\\rangle\n\n    Let n be the number of qubits representing the state, d the degree of p(x) and q_i the qubits,\n    where q_0 is the least significant qubit. Then for\n\n    .. math::\n\n        x = \\sum_{i=0}^{n-1} 2^i q_i,\n\n    we can write\n\n    .. math::\n\n        p(x) = \\sum_{j=0}^{j=d} c_j x^j\n\n    where :math:`c` are the input coefficients, ``coeffs``.\n    ",
    "parameters": {
      "num_state_qubits": {
        "default": null,
        "annotation": "int | None"
      },
      "coeffs": {
        "default": null,
        "annotation": "list[float] | None"
      },
      "basis": {
        "default": "Y",
        "annotation": "str"
      },
      "name": {
        "default": "poly",
        "annotation": "str"
      }
    }
  },
  {
    "class_name": "QuadraticForm",
    "module": "qiskit.circuit.library.arithmetic.quadratic_form",
    "doc": "Implements a quadratic form on binary variables encoded in qubit registers.\n\n    A quadratic form on binary variables is a quadratic function :math:`Q` acting on a binary\n    variable of :math:`n` bits, :math:`x = x_0 ... x_{n-1}`. For an integer matrix :math:`A`,\n    an integer vector :math:`b` and an integer :math:`c` the function can be written as\n\n    .. math::\n\n        Q(x) = x^T A x + x^T b + c\n\n    If :math:`A`, :math:`b` or :math:`c` contain scalar values, this circuit computes only\n    an approximation of the quadratic form.\n\n    Provided with :math:`m` qubits to encode the value, this circuit computes :math:`Q(x) \\mod 2^m`\n    in [two's complement](https://stackoverflow.com/questions/1049722/what-is-2s-complement)\n    representation.\n\n    .. math::\n\n        |x\\rangle_n |0\\rangle_m \\mapsto |x\\rangle_n |(Q(x) + 2^m) \\mod 2^m \\rangle_m\n\n    Since we use two's complement e.g. the value of :math:`Q(x) = 3` requires 2 bits to represent\n    the value and 1 bit for the sign: `3 = '011'` where the first `0` indicates a positive value.\n    On the other hand, :math:`Q(x) = -3` would be `-3 = '101'`, where the first `1` indicates\n    a negative value and `01` is the two's complement of `3`.\n\n    If the value of :math:`Q(x)` is too large to be represented with `m` qubits, the resulting\n    bitstring is :math:`(Q(x) + 2^m) \\mod 2^m)`.\n\n    The implementation of this circuit is discussed in [1], Fig. 6.\n\n    References:\n\n    [1] Gilliam et al., Grover Adaptive Search for Constrained Polynomial Binary Optimization.\n    `arXiv:1912.04088 <https://arxiv.org/pdf/1912.04088.pdf>`_\n\n    ",
    "parameters": {
      "num_result_qubits": {
        "default": null,
        "annotation": "Optional[int]"
      },
      "quadratic": {
        "default": null,
        "annotation": "Optional[Union[np.ndarray, List[List[Union[float, ParameterExpression]]]]]"
      },
      "linear": {
        "default": null,
        "annotation": "Optional[Union[np.ndarray, List[Union[float, ParameterExpression]]]]"
      },
      "offset": {
        "default": null,
        "annotation": "Optional[Union[float, ParameterExpression]]"
      },
      "little_endian": {
        "default": true,
        "annotation": "bool"
      }
    }
  },
  {
    "class_name": "RGQFTMultiplier",
    "module": "qiskit.circuit.library.arithmetic.multipliers.rg_qft_multiplier",
    "doc": "A QFT multiplication circuit to store product of two input registers out-of-place.\n\n    Multiplication in this circuit is implemented using the procedure of Fig. 3 in [1], where\n    weighted sum rotations are implemented as given in Fig. 5 in [1]. QFT is used on the output\n    register and is followed by rotations controlled by input registers. The rotations\n    transform the state into the product of two input registers in QFT base, which is\n    reverted from QFT base using inverse QFT.\n    As an example, a circuit that performs a modular QFT multiplication on two 2-qubit\n    sized input registers with an output register of 2 qubits, is as follows:\n\n    .. code-block:: text\n\n          a_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                                                       \u2502       \u2502      \u2502      \u2502\n          a_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                        \u2502       \u2502       \u2502       \u2502      \u2502       \u2502      \u2502      \u2502\n          b_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                        \u2502       \u2502       \u2502       \u2502      \u2502       \u2502      \u2502      \u2502\n          b_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502P(4\u03c0)  \u2502       \u2502P(2\u03c0)  \u2502      \u2502P(2\u03c0)  \u2502      \u2502P(\u03c0)  \u2502       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        out_0: \u25240     \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25240      \u251c\n               \u2502  qft \u2502         \u2502P(2\u03c0)          \u2502P(\u03c0)          \u2502P(\u03c0)         \u2502P(\u03c0/2) \u2502  iqft \u2502\n        out_1: \u25241     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25241      \u251c\n               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    .. seealso::\n\n        The :class:`.MultiplierGate` objects represents a multiplication, like this circuit class,\n        but allows the compiler to select the optimal decomposition based on the context.\n        Specific implementations can be set via the :class:`.HLSConfig`, e.g. this circuit\n        can be chosen via ``Multiplier=[\"qft_r17\"]``.\n\n    References:\n\n    [1] Ruiz-Perez et al., Quantum arithmetic with the Quantum Fourier Transform, 2017.\n    `arXiv:1411.5949 <https://arxiv.org/pdf/1411.5949.pdf>`_\n\n    ",
    "parameters": {
      "num_state_qubits": {
        "default": null,
        "annotation": "<class 'int'>"
      },
      "num_result_qubits": {
        "default": null,
        "annotation": "typing.Optional[int]"
      },
      "name": {
        "default": "RGQFTMultiplier",
        "annotation": "<class 'str'>"
      }
    }
  },
  {
    "class_name": "VBERippleCarryAdder",
    "module": "qiskit.circuit.library.arithmetic.adders.vbe_ripple_carry_adder",
    "doc": "The VBE ripple carry adder [1].\n\n    This circuit performs inplace addition of two equally-sized quantum registers.\n    As an example, a classical adder circuit that performs full addition (i.e. including\n    a carry-in bit) on two 2-qubit sized registers is as follows:\n\n    .. code-block:: text\n\n                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n           cin_0: \u25240       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25240          \u251c\u25240     \u251c\n                  \u2502        \u2502                       \u2502           \u2502\u2502      \u2502\n             a_0: \u25241       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25241          \u251c\u25241     \u251c\n                  \u2502        \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502           \u2502\u2502  Sum \u2502\n             a_1: \u2524        \u251c\u25241       \u251c\u2500\u2500\u25a0\u2500\u2500\u25241     \u251c\u2524           \u251c\u2524      \u251c\n                  \u2502        \u2502\u2502        \u2502  \u2502  \u2502      \u2502\u2502           \u2502\u2502      \u2502\n             b_0: \u25242 Carry \u251c\u2524        \u251c\u2500\u2500\u253c\u2500\u2500\u2524      \u251c\u25242 Carry_dg \u251c\u25242     \u251c\n                  \u2502        \u2502\u2502        \u2502\u250c\u2500\u2534\u2500\u2510\u2502      \u2502\u2502           \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             b_1: \u2524        \u251c\u25242 Carry \u251c\u2524 X \u251c\u25242 Sum \u251c\u2524           \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                  \u2502        \u2502\u2502        \u2502\u2514\u2500\u2500\u2500\u2518\u2502      \u2502\u2502           \u2502\n          cout_0: \u2524        \u251c\u25243       \u251c\u2500\u2500\u2500\u2500\u2500\u2524      \u251c\u2524           \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                  \u2502        \u2502\u2502        \u2502     \u2502      \u2502\u2502           \u2502\n        helper_0: \u25243       \u251c\u25240       \u251c\u2500\u2500\u2500\u2500\u2500\u25240     \u251c\u25243          \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\n    Here *Carry* and *Sum* gates correspond to the gates introduced in [1].\n    *Carry_dg* correspond to the inverse of the *Carry* gate. Note that\n    in this implementation the input register qubits are ordered as all qubits from\n    the first input register, followed by all qubits from the second input register.\n    This is different ordering as compared to Figure 2 in [1], which leads to a different\n    drawing of the circuit.\n\n    .. seealso::\n\n        The following generic gate objects perform additions, like this circuit class,\n        but allow the compiler to select the optimal decomposition based on the context.\n        Specific implementations can be set via the :class:`.HLSConfig`, e.g. this circuit\n        can be chosen via ``Adder=[\"ripple_v95\"]``.\n\n        :class:`.ModularAdderGate`: A generic inplace adder, modulo :math:`2^n`. This\n            is functionally equivalent to ``kind=\"fixed\"``.\n\n        :class:`.AdderGate`: A generic inplace adder. This\n            is functionally equivalent to ``kind=\"half\"``.\n\n        :class:`.FullAdderGate`: A generic inplace adder, with a carry-in bit. This\n            is functionally equivalent to ``kind=\"full\"``.\n\n    References:\n\n    [1] Vedral et al., Quantum Networks for Elementary Arithmetic Operations, 1995.\n    `arXiv:quant-ph/9511018 <https://arxiv.org/pdf/quant-ph/9511018.pdf>`_\n\n    ",
    "parameters": {
      "num_state_qubits": {
        "default": null,
        "annotation": "int"
      },
      "kind": {
        "default": "full",
        "annotation": "str"
      },
      "name": {
        "default": "VBERippleCarryAdder",
        "annotation": "str"
      }
    }
  },
  {
    "class_name": "WeightedAdder",
    "module": "qiskit.circuit.library.arithmetic.weighted_adder",
    "doc": "A circuit to compute the weighted sum of qubit registers.\n\n    Given :math:`n` qubit basis states :math:`q_0, \\ldots, q_{n-1} \\in \\{0, 1\\}` and non-negative\n    integer weights :math:`\\lambda_0, \\ldots, \\lambda_{n-1}`, this circuit performs the operation\n\n    .. math::\n\n        |q_0 \\ldots q_{n-1}\\rangle |0\\rangle_s\n        \\mapsto |q_0 \\ldots q_{n-1}\\rangle |\\sum_{j=0}^{n-1} \\lambda_j q_j\\rangle_s\n\n    where :math:`s` is the number of sum qubits required.\n    This can be computed as\n\n    .. math::\n\n        s = 1 + \\left\\lfloor \\log_2\\left( \\sum_{j=0}^{n-1} \\lambda_j \\right) \\right\\rfloor\n\n    or :math:`s = 1` if the sum of the weights is 0 (then the expression in the logarithm is\n    invalid).\n\n    For qubits in a circuit diagram, the first weight applies to the upper-most qubit.\n    For an example where the state of 4 qubits is added into a sum register, the circuit can\n    be schematically drawn as\n\n    .. code-block:: text\n\n                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          state_0: \u25240       \u251c | state_0 * weights[0]\n                   \u2502        \u2502 |\n          state_1: \u25241       \u251c | + state_1 * weights[1]\n                   \u2502        \u2502 |\n          state_2: \u25242       \u251c | + state_2 * weights[2]\n                   \u2502        \u2502 |\n          state_3: \u25243       \u251c | + state_3 * weights[3]\n                   \u2502        \u2502\n            sum_0: \u25244       \u251c |\n                   \u2502  Adder \u2502 |\n            sum_1: \u25245       \u251c | = sum_0 * 2^0 + sum_1 * 2^1 + sum_2 * 2^2\n                   \u2502        \u2502 |\n            sum_2: \u25246       \u251c |\n                   \u2502        \u2502\n          carry_0: \u25247       \u251c\n                   \u2502        \u2502\n          carry_1: \u25248       \u251c\n                   \u2502        \u2502\n        control_0: \u25249       \u251c\n                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    ",
    "parameters": {
      "num_state_qubits": {
        "default": null,
        "annotation": "Optional[int]"
      },
      "weights": {
        "default": null,
        "annotation": "Optional[List[int]]"
      },
      "name": {
        "default": "adder",
        "annotation": "str"
      }
    }
  },
  {
    "class_name": "QFT",
    "module": "qiskit.circuit.library.basis_change.qft",
    "doc": "Quantum Fourier Transform Circuit.\n\n    The Quantum Fourier Transform (QFT) on :math:`n` qubits is the operation\n\n    .. math::\n\n        |j\\rangle \\mapsto \\frac{1}{2^{n/2}} \\sum_{k=0}^{2^n - 1} e^{2\\pi ijk / 2^n} |k\\rangle\n\n    The circuit that implements this transformation can be implemented using Hadamard gates\n    on each qubit, a series of controlled-U1 (or Z, depending on the phase) gates and a\n    layer of Swap gates. The layer of Swap gates can in principle be dropped if the QFT appears\n    at the end of the circuit, since then the re-ordering can be done classically. They\n    can be turned off using the ``do_swaps`` attribute.\n\n    For 4 qubits, the circuit that implements this transformation is:\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import QFT\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       circuit = QFT(4)\n       _generate_circuit_library_visualization(circuit)\n\n    The inverse QFT can be obtained by calling the ``inverse`` method on this class.\n    The respective circuit diagram is:\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import QFT\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       circuit = QFT(4).inverse()\n       _generate_circuit_library_visualization(circuit)\n\n    One method to reduce circuit depth is to implement the QFT approximately by ignoring\n    controlled-phase rotations where the angle is beneath a threshold. This is discussed\n    in more detail in https://arxiv.org/abs/quant-ph/9601018 or\n    https://arxiv.org/abs/quant-ph/0403071.\n\n    Here, this can be adjusted using the ``approximation_degree`` attribute: the smallest\n    ``approximation_degree`` rotation angles are dropped from the QFT. For instance, a QFT\n    on 5 qubits with approximation degree 2 yields (the barriers are dropped in this example):\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import QFT\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       circuit = QFT(5, approximation_degree=2)\n       _generate_circuit_library_visualization(circuit)\n\n    ",
    "parameters": {
      "num_qubits": {
        "default": null,
        "annotation": "int | None"
      },
      "approximation_degree": {
        "default": 0,
        "annotation": "int"
      },
      "do_swaps": {
        "default": true,
        "annotation": "bool"
      },
      "inverse": {
        "default": false,
        "annotation": "bool"
      },
      "insert_barriers": {
        "default": false,
        "annotation": "bool"
      },
      "name": {
        "default": null,
        "annotation": "str | None"
      }
    }
  },
  {
    "class_name": "PauliFeatureMap",
    "module": "qiskit.circuit.library.data_preparation.pauli_feature_map",
    "doc": "The Pauli Expansion circuit.\n\n    The Pauli Expansion circuit is a data encoding circuit that transforms input data\n    :math:`\\vec{x} \\in \\mathbb{R}^n`, where `n` is the ``feature_dimension``, as\n\n    .. math::\n\n        U_{\\Phi(\\vec{x})}=\\exp\\left(i\\sum_{S \\in \\mathcal{I}}\n        \\phi_S(\\vec{x})\\prod_{i\\in S} P_i\\right).\n\n    Here, :math:`S` is a set of qubit indices that describes the connections in the feature map,\n    :math:`\\mathcal{I}` is a set containing all these index sets, and\n    :math:`P_i \\in \\{I, X, Y, Z\\}`. Per default the data-mapping\n    :math:`\\phi_S` is\n\n    .. math::\n\n        \\phi_S(\\vec{x}) = \\begin{cases}\n            x_i \\text{ if } S = \\{i\\} \\\\\n            \\prod_{j \\in S} (\\pi - x_j) \\text{ if } |S| > 1\n            \\end{cases}.\n\n    The possible connections can be set using the ``entanglement`` and ``paulis`` arguments.\n    For example, for single-qubit :math:`Z` rotations and two-qubit :math:`YY` interactions\n    between all qubit pairs, we can set::\n\n\n        feature_map = PauliFeatureMap(..., paulis=[\"Z\", \"YY\"], entanglement=\"full\")\n\n    which will produce blocks of the form\n\n    .. code-block:: text\n\n        \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2524 H \u251c\u2524 P(2.0*x[0]) \u251c\u2524 RX(pi/2) \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 RX(-pi/2) \u251c\n        \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2524 H \u251c\u2524 P(2.0*x[1]) \u251c\u2524 RX(pi/2) \u251c\u2524 X \u251c\u2524 P(2.0*(pi - x[0])*(pi - x[1])) \u251c\u2524 X \u251c\u2524 RX(-pi/2) \u251c\n        \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    The circuit contains ``reps`` repetitions of this transformation.\n\n    Please refer to :class:`.ZFeatureMap` for the case of single-qubit Pauli-:math:`Z` rotations\n    and to :class:`.ZZFeatureMap` for the single- and two-qubit Pauli-:math:`Z` rotations.\n\n    Examples:\n\n        >>> prep = PauliFeatureMap(2, reps=1, paulis=['ZZ'])\n        >>> print(prep.decompose())\n             \u250c\u2500\u2500\u2500\u2510\n        q_0: \u2524 H \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\n             \u251c\u2500\u2500\u2500\u2524\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\n        q_1: \u2524 H \u251c\u2524 X \u251c\u2524 P(2.0*(pi - x[0])*(pi - x[1])) \u251c\u2524 X \u251c\n             \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\n\n        >>> prep = PauliFeatureMap(2, reps=1, paulis=['Z', 'XX'])\n        >>> print(prep.decompose())\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510                                            \u250c\u2500\u2500\u2500\u2510\n        q_0: \u2524 H \u251c\u2524 P(2.0*x[0]) \u251c\u2524 H \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 H \u251c\n             \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2524\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u251c\u2500\u2500\u2500\u2524\n        q_1: \u2524 H \u251c\u2524 P(2.0*x[1]) \u251c\u2524 H \u251c\u2524 X \u251c\u2524 P(2.0*(pi - x[0])*(pi - x[1])) \u251c\u2524 X \u251c\u2524 H \u251c\n             \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\n\n        >>> prep = PauliFeatureMap(2, reps=1, paulis=['ZY'])\n        >>> print(prep.decompose())\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 H \u251c\u2524 RX(pi/2) \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 RX(-pi/2) \u251c\n             \u251c\u2500\u2500\u2500\u2524\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        q_1: \u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2524 P(2.0*(pi - x[0])*(pi - x[1])) \u251c\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\n\n        >>> from qiskit.circuit.library import EfficientSU2\n        >>> prep = PauliFeatureMap(3, reps=3, paulis=['Z', 'YY', 'ZXZ'])\n        >>> wavefunction = EfficientSU2(3)\n        >>> classifier = prep.compose(wavefunction)\n        >>> classifier.num_parameters\n        27\n        >>> classifier.count_ops()\n        OrderedDict([('cx', 39), ('rx', 36), ('u1', 21), ('h', 15), ('ry', 12), ('rz', 12)])\n\n    References:\n\n    [1] Havlicek et al. Supervised learning with quantum enhanced feature spaces,\n    `Nature 567, 209-212 (2019) <https://www.nature.com/articles/s41586-019-0980-2>`__.\n    ",
    "parameters": {
      "feature_dimension": {
        "default": null,
        "annotation": "Optional[int]"
      },
      "reps": {
        "default": 2,
        "annotation": "int"
      },
      "entanglement": {
        "default": "full",
        "annotation": "Union[str, Dict[int, List[Tuple[int]]], Callable[[int], Union[str, Dict[int, List[Tuple[int]]]]]]"
      },
      "alpha": {
        "default": 2.0,
        "annotation": "float"
      },
      "paulis": {
        "default": null,
        "annotation": "Optional[List[str]]"
      },
      "data_map_func": {
        "default": null,
        "annotation": "Optional[Callable[[np.ndarray], float]]"
      },
      "parameter_prefix": {
        "default": "x",
        "annotation": "str"
      },
      "insert_barriers": {
        "default": false,
        "annotation": "bool"
      },
      "name": {
        "default": "PauliFeatureMap",
        "annotation": "str"
      }
    }
  },
  {
    "class_name": "ZFeatureMap",
    "module": "qiskit.circuit.library.data_preparation._z_feature_map",
    "doc": "The first order Pauli Z-evolution circuit.\n\n    On 3 qubits and with 2 repetitions the circuit is represented by:\n\n    .. code-block:: text\n\n        \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2524 H \u251c\u2524 P(2.0*x[0]) \u251c\u2524 H \u251c\u2524 P(2.0*x[0]) \u251c\n        \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2524 H \u251c\u2524 U(2.0*x[1]) \u251c\u2524 H \u251c\u2524 P(2.0*x[1]) \u251c\n        \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2524 H \u251c\u2524 P(2.0*x[2]) \u251c\u2524 H \u251c\u2524 P(2.0*x[2]) \u251c\n        \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    This is a sub-class of :class:`~qiskit.circuit.library.PauliFeatureMap` where the Pauli\n    strings are fixed as `['Z']`. As a result the first order expansion will be a circuit without\n    entangling gates.\n\n    Examples:\n\n        >>> prep = ZFeatureMap(3, reps=3, insert_barriers=True)\n        >>> print(prep.decompose())\n             \u250c\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 H \u251c\u2500\u2591\u2500\u2524 P(2.0*x[0]) \u251c\u2500\u2591\u2500\u2524 H \u251c\u2500\u2591\u2500\u2524 P(2.0*x[0]) \u251c\u2500\u2591\u2500\u2524 H \u251c\u2500\u2591\u2500\u2524 P(2.0*x[0]) \u251c\n             \u251c\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_1: \u2524 H \u251c\u2500\u2591\u2500\u2524 P(2.0*x[1]) \u251c\u2500\u2591\u2500\u2524 H \u251c\u2500\u2591\u2500\u2524 P(2.0*x[1]) \u251c\u2500\u2591\u2500\u2524 H \u251c\u2500\u2591\u2500\u2524 P(2.0*x[1]) \u251c\n             \u251c\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_2: \u2524 H \u251c\u2500\u2591\u2500\u2524 P(2.0*x[2]) \u251c\u2500\u2591\u2500\u2524 H \u251c\u2500\u2591\u2500\u2524 P(2.0*x[2]) \u251c\u2500\u2591\u2500\u2524 H \u251c\u2500\u2591\u2500\u2524 P(2.0*x[2]) \u251c\n             \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> data_map = lambda x: x[0]*x[0] + 1  # note: input is an array\n        >>> prep = ZFeatureMap(3, reps=1, data_map_func=data_map)\n        >>> print(prep.decompose())\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 H \u251c\u2524 P(2.0*x[0]**2 + 2.0) \u251c\n             \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_1: \u2524 H \u251c\u2524 P(2.0*x[1]**2 + 2.0) \u251c\n             \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_2: \u2524 H \u251c\u2524 P(2.0*x[2]**2 + 2.0) \u251c\n             \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> from qiskit.circuit.library import TwoLocal\n        >>> ry = TwoLocal(3, \"ry\", \"cz\", reps=1)\n        >>> classifier = ZFeatureMap(3, reps=1) + ry\n        >>> print(classifier.decompose())\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 H \u251c\u2524 P(2.0*x[0]) \u251c\u2524 RY(\u03b8[0]) \u251c\u2500\u25a0\u2500\u2500\u25a0\u2500\u2524 RY(\u03b8[3]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502  \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_1: \u2524 H \u251c\u2524 P(2.0*x[1]) \u251c\u2524 RY(\u03b8[1]) \u251c\u2500\u25a0\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 RY(\u03b8[4]) \u251c\n             \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524    \u2502      \u2502      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_2: \u2524 H \u251c\u2524 P(2.0*x[2]) \u251c\u2524 RY(\u03b8[2]) \u251c\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 RY(\u03b8[5]) \u251c\n             \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    ",
    "parameters": {
      "feature_dimension": {
        "default": null,
        "annotation": "<class 'int'>"
      },
      "reps": {
        "default": 2,
        "annotation": "<class 'int'>"
      },
      "data_map_func": {
        "default": null,
        "annotation": "typing.Optional[typing.Callable[[numpy.ndarray], float]]"
      },
      "parameter_prefix": {
        "default": "x",
        "annotation": "<class 'str'>"
      },
      "insert_barriers": {
        "default": false,
        "annotation": "<class 'bool'>"
      },
      "name": {
        "default": "ZFeatureMap",
        "annotation": "<class 'str'>"
      }
    }
  },
  {
    "class_name": "ZZFeatureMap",
    "module": "qiskit.circuit.library.data_preparation._zz_feature_map",
    "doc": "Second-order Pauli-Z evolution circuit.\n\n    For 3 qubits and 1 repetition and linear entanglement the circuit is represented by:\n\n    .. code-block:: text\n\n        \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2524 H \u251c\u2524 P(2.0*\u03c6(x[0])) \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\n        \u2524 H \u251c\u2524 P(2.0*\u03c6(x[1])) \u251c\u2524 X \u251c\u2524 P(2.0*\u03c6(x[0],x[1])) \u251c\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\n        \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\n        \u2524 H \u251c\u2524 P(2.0*\u03c6(x[2])) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2524 P(2.0*\u03c6(x[1],x[2])) \u251c\u2524 X \u251c\n        \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                 \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\n\n    where :math:`\\varphi` is a classical non-linear function, which defaults to :math:`\\varphi(x) = x`\n    if and :math:`\\varphi(x,y) = (\\pi - x)(\\pi - y)`.\n\n    Examples:\n\n    .. code-block::\n\n         from qiskit.circuit.library import ZZFeatureMap\n         prep = ZZFeatureMap(2, reps=1)\n         print(prep.decompose())\n\n    .. code-block:: text\n\n              \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         q_0: \u2524 H \u251c\u2524 P(2.0*x[0]) \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\n              \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\n         q_1: \u2524 H \u251c\u2524 P(2.0*x[1]) \u251c\u2524 X \u251c\u2524 P(2.0*(pi - x[0])*(pi - x[1])) \u251c\u2524 X \u251c\n              \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\n\n    .. code-block::\n\n         from qiskit.circuit.library import EfficientSU2\n         classifier = ZZFeatureMap(3).compose(EfficientSU2(3))\n         classifier.num_parameters\n\n    .. code-block:: text\n\n         27\n\n    .. code-block::\n\n         classifier.parameters  # 'x' for the data preparation, '\u03b8' for the SU2 parameters\n\n    .. code-block:: text\n\n         ParameterView([\n             ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),\n             ParameterVectorElement(x[2]), ParameterVectorElement(\u03b8[0]),\n             ParameterVectorElement(\u03b8[1]), ParameterVectorElement(\u03b8[2]),\n             ParameterVectorElement(\u03b8[3]), ParameterVectorElement(\u03b8[4]),\n             ParameterVectorElement(\u03b8[5]), ParameterVectorElement(\u03b8[6]),\n             ParameterVectorElement(\u03b8[7]), ParameterVectorElement(\u03b8[8]),\n             ParameterVectorElement(\u03b8[9]), ParameterVectorElement(\u03b8[10]),\n             ParameterVectorElement(\u03b8[11]), ParameterVectorElement(\u03b8[12]),\n             ParameterVectorElement(\u03b8[13]), ParameterVectorElement(\u03b8[14]),\n             ParameterVectorElement(\u03b8[15]), ParameterVectorElement(\u03b8[16]),\n             ParameterVectorElement(\u03b8[17]), ParameterVectorElement(\u03b8[18]),\n             ParameterVectorElement(\u03b8[19]), ParameterVectorElement(\u03b8[20]),\n             ParameterVectorElement(\u03b8[21]), ParameterVectorElement(\u03b8[22]),\n             ParameterVectorElement(\u03b8[23])\n         ])\n\n    .. code-block::\n\n         classifier.count_ops()\n\n    .. code-block:: text\n\n        OrderedDict([('ZZFeatureMap', 1), ('EfficientSU2', 1)])\n\n    ",
    "parameters": {
      "feature_dimension": {
        "default": null,
        "annotation": "<class 'int'>"
      },
      "reps": {
        "default": 2,
        "annotation": "<class 'int'>"
      },
      "entanglement": {
        "default": "full",
        "annotation": "typing.Union[str, typing.Dict[int, typing.List[typing.Tuple[int]]], typing.Callable[[int], typing.Union[str, typing.Dict[int, typing.List[typing.Tuple[int]]]]]]"
      },
      "data_map_func": {
        "default": null,
        "annotation": "typing.Optional[typing.Callable[[numpy.ndarray], float]]"
      },
      "parameter_prefix": {
        "default": "x",
        "annotation": "<class 'str'>"
      },
      "insert_barriers": {
        "default": false,
        "annotation": "<class 'bool'>"
      },
      "name": {
        "default": "ZZFeatureMap",
        "annotation": "<class 'str'>"
      }
    }
  },
  {
    "class_name": "EfficientSU2",
    "module": "qiskit.circuit.library.n_local.efficient_su2",
    "doc": "The hardware efficient SU(2) 2-local circuit.\n\n    The ``EfficientSU2`` circuit consists of layers of single qubit operations spanned by SU(2)\n    and :math:`CX` entanglements. This is a heuristic pattern that can be used to prepare trial wave\n    functions for variational quantum algorithms or classification circuit for machine learning.\n\n    SU(2) stands for special unitary group of degree 2, its elements are :math:`2 \\times 2`\n    unitary matrices with determinant 1, such as the Pauli rotation gates.\n\n    On 3 qubits and using the Pauli :math:`Y` and :math:`Z` su2_gates as single qubit gates, the\n    hardware efficient SU(2) circuit is represented by:\n\n    .. code-block:: text\n\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591            \u2591       \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2524 RY(\u03b8[0]) \u251c\u2524 RZ(\u03b8[3]) \u251c\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2591\u2500 ... \u2500\u2591\u2500\u2524 RY(\u03b8[12]) \u251c\u2524 RZ(\u03b8[15]) \u251c\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591      \u250c\u2500\u2534\u2500\u2510 \u2591       \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2524 RY(\u03b8[1]) \u251c\u2524 RZ(\u03b8[4]) \u251c\u2500\u2591\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2591\u2500 ... \u2500\u2591\u2500\u2524 RY(\u03b8[13]) \u251c\u2524 RZ(\u03b8[16]) \u251c\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518 \u2591       \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2524 RY(\u03b8[2]) \u251c\u2524 RZ(\u03b8[5]) \u251c\u2500\u2591\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500 ... \u2500\u2591\u2500\u2524 RY(\u03b8[14]) \u251c\u2524 RZ(\u03b8[17]) \u251c\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2518      \u2591       \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    See :class:`~qiskit.circuit.library.RealAmplitudes` for more detail on the possible arguments\n    and options such as skipping unentanglement qubits, which apply here too.\n\n    Examples:\n\n        >>> circuit = EfficientSU2(3, reps=1)\n        >>> print(circuit.decompose())\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 RY(\u03b8[0]) \u251c\u2524 RZ(\u03b8[3]) \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 RY(\u03b8[6]) \u251c\u2524 RZ(\u03b8[9]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u250c\u2500\u2534\u2500\u2510  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_1: \u2524 RY(\u03b8[1]) \u251c\u2524 RZ(\u03b8[4]) \u251c\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 RY(\u03b8[7]) \u251c\u2524 RZ(\u03b8[10]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510   \u250c\u2500\u2534\u2500\u2510    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_2: \u2524 RY(\u03b8[2]) \u251c\u2524 RZ(\u03b8[5]) \u251c\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2524 RY(\u03b8[8]) \u251c\u2524 RZ(\u03b8[11]) \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> ansatz = EfficientSU2(4, su2_gates=['rx', 'y'], entanglement='circular', reps=1,\n        ... flatten=True)\n        >>> qc = QuantumCircuit(4)  # create a circuit and append the RY variational form\n        >>> qc.compose(ansatz, inplace=True)\n        >>> qc.draw()\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510\n        q_0: \u2524 RX(\u03b8[0]) \u251c\u2524 Y \u251c\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2524 RX(\u03b8[4]) \u251c\u2500\u2500\u2500\u2524 Y \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2524\u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510\n        q_1: \u2524 RX(\u03b8[1]) \u251c\u2524 Y \u251c\u2500\u2500\u253c\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 RX(\u03b8[5]) \u251c\u2500\u2500\u2500\u2524 Y \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2524  \u2502  \u2514\u2500\u2500\u2500\u2518   \u250c\u2500\u2534\u2500\u2510    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\n        q_2: \u2524 RX(\u03b8[2]) \u251c\u2524 Y \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 RX(\u03b8[6]) \u251c\u2524 Y \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2524  \u2502          \u2514\u2500\u2500\u2500\u2518       \u250c\u2500\u2534\u2500\u2510    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2524\n        q_3: \u2524 RX(\u03b8[3]) \u251c\u2524 Y \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2524 RX(\u03b8[7]) \u251c\u2524 Y \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518                         \u2514\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\n\n    .. seealso::\n\n        The :func:`.efficient_su2` function constructs a functionally equivalent circuit, but faster.\n\n    ",
    "parameters": {
      "num_qubits": {
        "default": null,
        "annotation": "int | None"
      },
      "su2_gates": {
        "default": null,
        "annotation": "str | type | qiskit.circuit.Instruction | QuantumCircuit | list[str | type | qiskit.circuit.Instruction | QuantumCircuit] | None"
      },
      "entanglement": {
        "default": "reverse_linear",
        "annotation": "str | list[list[int]] | Callable[[int], list[int]]"
      },
      "reps": {
        "default": 3,
        "annotation": "int"
      },
      "skip_unentangled_qubits": {
        "default": false,
        "annotation": "bool"
      },
      "skip_final_rotation_layer": {
        "default": false,
        "annotation": "bool"
      },
      "parameter_prefix": {
        "default": "\u03b8",
        "annotation": "str"
      },
      "insert_barriers": {
        "default": false,
        "annotation": "bool"
      },
      "initial_state": {
        "default": null,
        "annotation": "QuantumCircuit | None"
      },
      "name": {
        "default": "EfficientSU2",
        "annotation": "str"
      },
      "flatten": {
        "default": null,
        "annotation": "bool | None"
      }
    }
  },
  {
    "class_name": "EvolvedOperatorAnsatz",
    "module": "qiskit.circuit.library.n_local.evolved_operator_ansatz",
    "doc": "The evolved operator ansatz.",
    "parameters": {
      "operators": {
        "default": null,
        "annotation": null
      },
      "reps": {
        "default": 1,
        "annotation": "int"
      },
      "evolution": {
        "default": null,
        "annotation": null
      },
      "insert_barriers": {
        "default": false,
        "annotation": "bool"
      },
      "name": {
        "default": "EvolvedOps",
        "annotation": "str"
      },
      "parameter_prefix": {
        "default": "t",
        "annotation": "str | Sequence[str]"
      },
      "initial_state": {
        "default": null,
        "annotation": "QuantumCircuit | None"
      },
      "flatten": {
        "default": null,
        "annotation": "bool | None"
      }
    }
  },
  {
    "class_name": "ExcitationPreserving",
    "module": "qiskit.circuit.library.n_local.excitation_preserving",
    "doc": "The heuristic excitation-preserving wave function ansatz.\n\n    The ``ExcitationPreserving`` circuit preserves the ratio of :math:`|00\\rangle`,\n    :math:`|01\\rangle + |10\\rangle` and :math:`|11\\rangle` states. To this end, this circuit\n    uses two-qubit interactions of the form\n\n    .. math::\n\n        \\newcommand{\\rotationangle}{\\theta/2}\n\n        \\begin{pmatrix}\n        1 & 0 & 0 & 0 \\\\\n        0 & \\cos\\left(\\rotationangle\\right) & -i\\sin\\left(\\rotationangle\\right) & 0 \\\\\n        0 & -i\\sin\\left(\\rotationangle\\right) & \\cos\\left(\\rotationangle\\right) & 0 \\\\\n        0 & 0 & 0 & e^{-i\\phi}\n        \\end{pmatrix}\n\n    for the mode ``'fsim'`` or with :math:`e^{-i\\phi} = 1` for the mode ``'iswap'``.\n\n    Note that other wave functions, such as UCC-ansatzes, are also excitation preserving.\n    However these can become complex quickly, while this heuristically motivated circuit follows\n    a simpler pattern.\n\n    This trial wave function consists of layers of :math:`Z` rotations with 2-qubit entanglements.\n    The entangling is creating using :math:`XX+YY` rotations and optionally a controlled-phase\n    gate for the mode ``'fsim'``.\n\n    See :class:`~qiskit.circuit.library.RealAmplitudes` for more detail on the possible arguments\n    and options such as skipping unentanglement qubits, which apply here too.\n\n    The rotations of the ExcitationPreserving ansatz can be written as\n\n    Examples:\n\n        >>> ansatz = ExcitationPreserving(3, reps=1, insert_barriers=True, entanglement='linear')\n        >>> print(ansatz.decompose())  # show the circuit\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 RZ(\u03b8[0]) \u251c\u2500\u2591\u2500\u25240           \u251c\u25240           \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 RZ(\u03b8[5]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u2502  RXX(\u03b8[3]) \u2502\u2502  RYY(\u03b8[3]) \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_1: \u2524 RZ(\u03b8[1]) \u251c\u2500\u2591\u2500\u25241           \u251c\u25241           \u251c\u25240           \u251c\u25240           \u251c\u2500\u2591\u2500\u2524 RZ(\u03b8[6]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502  RXX(\u03b8[4]) \u2502\u2502  RYY(\u03b8[4]) \u2502 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_2: \u2524 RZ(\u03b8[2]) \u251c\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25241           \u251c\u25241           \u251c\u2500\u2591\u2500\u2524 RZ(\u03b8[7]) \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> ansatz = ExcitationPreserving(2, reps=1, flatten=True)\n        >>> qc = QuantumCircuit(2)  # create a circuit and append the RY variational form\n        >>> qc.cry(0.2, 0, 1)  # do some previous operation\n        >>> qc.compose(ansatz, inplace=True)  # add the excitation-preserving\n        >>> qc.draw()\n                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2524 RZ(\u03b8[0]) \u251c\u25240           \u251c\u25240           \u251c\u2524 RZ(\u03b8[3]) \u251c\n             \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2502  RXX(\u03b8[2]) \u2502\u2502  RYY(\u03b8[2]) \u2502\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_1: \u2524 RY(0.2) \u251c\u2524 RZ(\u03b8[1]) \u251c\u25241           \u251c\u25241           \u251c\u2524 RZ(\u03b8[4]) \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> ansatz = ExcitationPreserving(3, reps=1, mode='fsim', entanglement=[[0,2]],\n        ... insert_barriers=True, flatten=True)\n        >>> print(ansatz.decompose())\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 RZ(\u03b8[0]) \u251c\u2500\u2591\u2500\u25240           \u251c\u25240           \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 RZ(\u03b8[5]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u2502            \u2502\u2502            \u2502 \u2502      \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_1: \u2524 RZ(\u03b8[1]) \u251c\u2500\u2591\u2500\u2524  RXX(\u03b8[3]) \u251c\u2524  RYY(\u03b8[3]) \u251c\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 RZ(\u03b8[6]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u2502            \u2502\u2502            \u2502 \u2502\u03b8[4]  \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_2: \u2524 RZ(\u03b8[2]) \u251c\u2500\u2591\u2500\u25241           \u251c\u25241           \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 RZ(\u03b8[7]) \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    .. seealso::\n\n        The :func:`.excitation_preserving` function constructs a functionally equivalent circuit,\n        but faster.\n\n    ",
    "parameters": {
      "num_qubits": {
        "default": null,
        "annotation": "int | None"
      },
      "mode": {
        "default": "iswap",
        "annotation": "str"
      },
      "entanglement": {
        "default": "full",
        "annotation": "str | list[list[int]] | Callable[[int], list[int]]"
      },
      "reps": {
        "default": 3,
        "annotation": "int"
      },
      "skip_unentangled_qubits": {
        "default": false,
        "annotation": "bool"
      },
      "skip_final_rotation_layer": {
        "default": false,
        "annotation": "bool"
      },
      "parameter_prefix": {
        "default": "\u03b8",
        "annotation": "str"
      },
      "insert_barriers": {
        "default": false,
        "annotation": "bool"
      },
      "initial_state": {
        "default": null,
        "annotation": "QuantumCircuit | None"
      },
      "name": {
        "default": "ExcitationPreserving",
        "annotation": "str"
      },
      "flatten": {
        "default": null,
        "annotation": "bool | None"
      }
    }
  },
  {
    "class_name": "NLocal",
    "module": "qiskit.circuit.library.n_local.n_local",
    "doc": "The n-local circuit class.\n\n    The structure of the n-local circuit are alternating rotation and entanglement layers.\n    In both layers, parameterized circuit-blocks act on the circuit in a defined way.\n    In the rotation layer, the blocks are applied stacked on top of each other, while in the\n    entanglement layer according to the ``entanglement`` strategy.\n    The circuit blocks can have arbitrary sizes (smaller equal to the number of qubits in the\n    circuit). Each layer is repeated ``reps`` times, and by default a final rotation layer is\n    appended.\n\n    For instance, a rotation block on 2 qubits and an entanglement block on 4 qubits using\n    ``'linear'`` entanglement yields the following circuit.\n\n    .. code-block:: text\n\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510                      \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u25240     \u251c\u2500\u2591\u2500\u25240     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 ... \u2500\u2591\u2500\u25240     \u251c\n        \u2502  Rot \u2502 \u2591 \u2502      \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2591 \u2502  Rot \u2502\n        \u25241     \u251c\u2500\u2591\u2500\u25241     \u251c\u25240     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 ... \u2500\u2591\u2500\u25241     \u251c\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u2502  Ent \u2502\u2502      \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u25240     \u251c\u2500\u2591\u2500\u25242     \u251c\u25241     \u251c\u25240     \u251c ... \u2500\u2591\u2500\u25240     \u251c\n        \u2502  Rot \u2502 \u2591 \u2502      \u2502\u2502  Ent \u2502\u2502      \u2502      \u2591 \u2502  Rot \u2502\n        \u25241     \u251c\u2500\u2591\u2500\u25243     \u251c\u25242     \u251c\u25241     \u251c ... \u2500\u2591\u2500\u25241     \u251c\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502      \u2502\u2502  Ent \u2502      \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u25240     \u251c\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25243     \u251c\u25242     \u251c ... \u2500\u2591\u2500\u25240     \u251c\n        \u2502  Rot \u2502 \u2591         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502      \u2502      \u2591 \u2502  Rot \u2502\n        \u25241     \u251c\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25243     \u251c ... \u2500\u2591\u2500\u25241     \u251c\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        |                                 |\n        +---------------------------------+\n               repeated reps times\n\n    If specified, barriers can be inserted in between every block.\n    If an initial state object is provided, it is added in front of the NLocal.\n\n    .. seealso::\n\n        The :func:`.n_local` function constructs a functionally equivalent circuit, but faster.\n\n    ",
    "parameters": {
      "num_qubits": {
        "default": null,
        "annotation": "int | None"
      },
      "rotation_blocks": {
        "default": null,
        "annotation": "QuantumCircuit | list[QuantumCircuit] | qiskit.circuit.Instruction | list[qiskit.circuit.Instruction] | None"
      },
      "entanglement_blocks": {
        "default": null,
        "annotation": "QuantumCircuit | list[QuantumCircuit] | qiskit.circuit.Instruction | list[qiskit.circuit.Instruction] | None"
      },
      "entanglement": {
        "default": null,
        "annotation": "list[int] | list[list[int]] | None"
      },
      "reps": {
        "default": 1,
        "annotation": "int"
      },
      "insert_barriers": {
        "default": false,
        "annotation": "bool"
      },
      "parameter_prefix": {
        "default": "\u03b8",
        "annotation": "str"
      },
      "overwrite_block_parameters": {
        "default": true,
        "annotation": "bool | list[list[Parameter]]"
      },
      "skip_final_rotation_layer": {
        "default": false,
        "annotation": "bool"
      },
      "skip_unentangled_qubits": {
        "default": false,
        "annotation": "bool"
      },
      "initial_state": {
        "default": null,
        "annotation": "QuantumCircuit | None"
      },
      "name": {
        "default": "nlocal",
        "annotation": "str | None"
      },
      "flatten": {
        "default": null,
        "annotation": "bool | None"
      }
    }
  },
  {
    "class_name": "PauliTwoDesign",
    "module": "qiskit.circuit.library.n_local.pauli_two_design",
    "doc": "The Pauli Two-Design ansatz.\n\n    This class implements a particular form of a 2-design circuit [1], which is frequently studied\n    in quantum machine learning literature, such as e.g. the investigating of Barren plateaus in\n    variational algorithms [2].\n\n    The circuit consists of alternating rotation and entanglement layers with\n    an initial layer of :math:`\\sqrt{H} = RY(\\pi/4)` gates.\n    The rotation layers contain single qubit Pauli rotations, where the axis is chosen uniformly\n    at random to be X, Y or Z. The entanglement layers is compromised of pairwise CZ gates\n    with a total depth of 2.\n\n    For instance, the circuit could look like this (but note that choosing a different seed\n    yields different Pauli rotations).\n\n    .. code-block:: text\n\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2591  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 RY(\u03c0/4) \u251c\u2524 RZ(\u03b8[0]) \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 RY(\u03b8[4]) \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2500\u2524 RZ(\u03b8[8]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502     \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502     \u2591  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_1: \u2524 RY(\u03c0/4) \u251c\u2524 RZ(\u03b8[1]) \u251c\u2500\u25a0\u2500\u2500\u25a0\u2500\u2500\u2591\u2500\u2524 RY(\u03b8[5]) \u251c\u2500\u25a0\u2500\u2500\u25a0\u2500\u2500\u2591\u2500\u2500\u2524 RX(\u03b8[9]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524    \u2502  \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524    \u2502  \u2591 \u250c\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_2: \u2524 RY(\u03c0/4) \u251c\u2524 RX(\u03b8[2]) \u251c\u2500\u25a0\u2500\u2500\u25a0\u2500\u2500\u2591\u2500\u2524 RY(\u03b8[6]) \u251c\u2500\u25a0\u2500\u2500\u25a0\u2500\u2500\u2591\u2500\u2524 RX(\u03b8[10]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502     \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502     \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_3: \u2524 RY(\u03c0/4) \u251c\u2524 RZ(\u03b8[3]) \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 RX(\u03b8[7]) \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 RY(\u03b8[11]) \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Examples:\n\n        .. plot::\n           :alt: Circuit diagram output by the previous code.\n           :include-source:\n\n           from qiskit.circuit.library import PauliTwoDesign\n           circuit = PauliTwoDesign(4, reps=2, seed=5, insert_barriers=True)\n           circuit.draw('mpl')\n\n    .. seealso::\n\n        The :func:`.pauli_two_design` function constructs the functionally same circuit, but faster.\n\n    References:\n\n        [1]: Nakata et al., Unitary 2-designs from random X- and Z-diagonal unitaries.\n            `arXiv:1502.07514 <https://arxiv.org/pdf/1502.07514.pdf>`_\n\n        [2]: McClean et al., Barren plateaus in quantum neural network training landscapes.\n             `arXiv:1803.11173 <https://arxiv.org/pdf/1803.11173.pdf>`_\n    ",
    "parameters": {
      "num_qubits": {
        "default": null,
        "annotation": "int | None"
      },
      "reps": {
        "default": 3,
        "annotation": "int"
      },
      "seed": {
        "default": null,
        "annotation": "int | None"
      },
      "insert_barriers": {
        "default": false,
        "annotation": "bool"
      },
      "name": {
        "default": "PauliTwoDesign",
        "annotation": "str"
      }
    }
  },
  {
    "class_name": "QAOAAnsatz",
    "module": "qiskit.circuit.library.n_local.qaoa_ansatz",
    "doc": "A generalized QAOA quantum circuit with a support of custom initial states and mixers.\n\n    References:\n\n    [1] Farhi et al., A Quantum Approximate Optimization Algorithm.\n    `arXiv:1411.4028 <https://arxiv.org/pdf/1411.4028>`_\n    ",
    "parameters": {
      "cost_operator": {
        "default": null,
        "annotation": null
      },
      "reps": {
        "default": 1,
        "annotation": "int"
      },
      "initial_state": {
        "default": null,
        "annotation": "QuantumCircuit | None"
      },
      "mixer_operator": {
        "default": null,
        "annotation": null
      },
      "name": {
        "default": "QAOA",
        "annotation": "str"
      },
      "flatten": {
        "default": null,
        "annotation": "bool | None"
      }
    }
  },
  {
    "class_name": "RealAmplitudes",
    "module": "qiskit.circuit.library.n_local.real_amplitudes",
    "doc": "The real-amplitudes 2-local circuit.\n\n    The ``RealAmplitudes`` circuit is a heuristic trial wave function used as Ansatz in chemistry\n    applications or classification circuits in machine learning. The circuit consists of\n    alternating layers of :math:`Y` rotations and :math:`CX` entanglements. The entanglement\n    pattern can be user-defined or selected from a predefined set.\n    It is called ``RealAmplitudes`` since the prepared quantum states will only have\n    real amplitudes, the complex part is always 0.\n\n    For example a ``RealAmplitudes`` circuit with 2 repetitions on 3 qubits with ``'reverse_linear'``\n    entanglement is\n\n    .. code-block:: text\n\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591            \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591            \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2524 Ry(\u03b8[0]) \u251c\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2591\u2500\u2524 Ry(\u03b8[3]) \u251c\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2591\u2500\u2524 Ry(\u03b8[6]) \u251c\n         \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591      \u250c\u2500\u2534\u2500\u2510 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591      \u250c\u2500\u2534\u2500\u2510 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n         \u2524 Ry(\u03b8[1]) \u251c\u2500\u2591\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2591\u2500\u2524 Ry(\u03b8[4]) \u251c\u2500\u2591\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2591\u2500\u2524 Ry(\u03b8[7]) \u251c\n         \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n         \u2524 Ry(\u03b8[2]) \u251c\u2500\u2591\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Ry(\u03b8[5]) \u251c\u2500\u2591\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Ry(\u03b8[8]) \u251c\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2518      \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2518      \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    The entanglement can be set using the ``entanglement`` keyword as string or a list of\n    index-pairs. See the documentation of :class:`~qiskit.circuit.library.TwoLocal` and\n    :class:`~qiskit.circuit.NLocal` for more detail. Additional options that can be set include the\n    number of repetitions, skipping rotation gates on qubits that are not entangled, leaving out\n    the final rotation layer and inserting barriers in between the rotation and entanglement\n    layers.\n\n    If some qubits are not entangled with other qubits it makes sense to not apply rotation gates\n    on these qubits, since a sequence of :math:`Y` rotations can be reduced to a single :math:`Y`\n    rotation with summed rotation angles.\n\n    Examples:\n\n        >>> ansatz = RealAmplitudes(3, reps=2)  # create the circuit on 3 qubits\n        >>> print(ansatz.decompose())\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 Ry(\u03b8[0]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Ry(\u03b8[3]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Ry(\u03b8[6]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524        \u250c\u2500\u2534\u2500\u2510    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524        \u250c\u2500\u2534\u2500\u2510    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_1: \u2524 Ry(\u03b8[1]) \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2524 Ry(\u03b8[4]) \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2524 Ry(\u03b8[7]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        q_2: \u2524 Ry(\u03b8[2]) \u251c\u2524 X \u251c\u2524 Ry(\u03b8[5]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2524 Ry(\u03b8[8]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> ansatz = RealAmplitudes(3, entanglement='full', reps=2, flatten=True)\n        >>> print(ansatz)\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 RY(\u03b8[0]) \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 RY(\u03b8[3]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 RY(\u03b8[6]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u250c\u2500\u2534\u2500\u2510  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_1: \u2524 RY(\u03b8[1]) \u251c\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 RY(\u03b8[4]) \u251c\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 RY(\u03b8[7]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510   \u250c\u2500\u2534\u2500\u2510    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510   \u250c\u2500\u2534\u2500\u2510    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_2: \u2524 RY(\u03b8[2]) \u251c\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2524 RY(\u03b8[5]) \u251c\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2524 RY(\u03b8[8]) \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> ansatz = RealAmplitudes(3, entanglement='linear', reps=2, insert_barriers=True,\n        ... flatten=True)\n        >>> qc = QuantumCircuit(3)  # create a circuit and append the RY variational form\n        >>> qc.compose(ansatz, inplace=True)\n        >>> qc.draw()\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591            \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591            \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 RY(\u03b8[0]) \u251c\u2500\u2591\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 RY(\u03b8[3]) \u251c\u2500\u2591\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 RY(\u03b8[6]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u250c\u2500\u2534\u2500\u2510      \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u250c\u2500\u2534\u2500\u2510      \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_1: \u2524 RY(\u03b8[1]) \u251c\u2500\u2591\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2591\u2500\u2524 RY(\u03b8[4]) \u251c\u2500\u2591\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2591\u2500\u2524 RY(\u03b8[7]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_2: \u2524 RY(\u03b8[2]) \u251c\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2591\u2500\u2524 RY(\u03b8[5]) \u251c\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2591\u2500\u2524 RY(\u03b8[8]) \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591      \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591      \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> ansatz = RealAmplitudes(4, reps=1, entanglement='circular', insert_barriers=True,\n        ... flatten=True)\n        >>> print(ansatz)\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2500\u2500\u2510                \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 RY(\u03b8[0]) \u251c\u2500\u2591\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 RY(\u03b8[4]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2534\u2500\u2510           \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_1: \u2524 RY(\u03b8[1]) \u251c\u2500\u2591\u2500\u2500\u2500\u253c\u2500\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 RY(\u03b8[5]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591   \u2502  \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510      \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_2: \u2524 RY(\u03b8[2]) \u251c\u2500\u2591\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2591\u2500\u2524 RY(\u03b8[6]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591   \u2502       \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_3: \u2524 RY(\u03b8[3]) \u251c\u2500\u2591\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2591\u2500\u2524 RY(\u03b8[7]) \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591                \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> ansatz = RealAmplitudes(4, reps=2, entanglement=[[0,3], [0,2]],\n        ... skip_unentangled_qubits=True, flatten=True)\n        >>> print(ansatz)\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 RY(\u03b8[0]) \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 RY(\u03b8[3]) \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 RY(\u03b8[6]) \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502       \u2502      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502       \u2502      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502     \u250c\u2500\u2534\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502     \u250c\u2500\u2534\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_2: \u2524 RY(\u03b8[1]) \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2524 RY(\u03b8[4]) \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2524 RY(\u03b8[7]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        q_3: \u2524 RY(\u03b8[2]) \u251c\u2524 X \u251c\u2524 RY(\u03b8[5]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2524 RY(\u03b8[8]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    .. seealso::\n\n        The :func:`.real_amplitudes` function constructs a functionally equivalent circuit, but faster.\n\n    ",
    "parameters": {
      "num_qubits": {
        "default": null,
        "annotation": "int | None"
      },
      "entanglement": {
        "default": "reverse_linear",
        "annotation": "str | list[list[int]] | Callable[[int], list[int]]"
      },
      "reps": {
        "default": 3,
        "annotation": "int"
      },
      "skip_unentangled_qubits": {
        "default": false,
        "annotation": "bool"
      },
      "skip_final_rotation_layer": {
        "default": false,
        "annotation": "bool"
      },
      "parameter_prefix": {
        "default": "\u03b8",
        "annotation": "str"
      },
      "insert_barriers": {
        "default": false,
        "annotation": "bool"
      },
      "initial_state": {
        "default": null,
        "annotation": "QuantumCircuit | None"
      },
      "name": {
        "default": "RealAmplitudes",
        "annotation": "str"
      },
      "flatten": {
        "default": null,
        "annotation": "bool | None"
      }
    }
  },
  {
    "class_name": "TwoLocal",
    "module": "qiskit.circuit.library.n_local.two_local",
    "doc": "The two-local circuit.\n\n    The two-local circuit is a parameterized circuit consisting of alternating rotation layers and\n    entanglement layers. The rotation layers are single qubit gates applied on all qubits.\n    The entanglement layer uses two-qubit gates to entangle the qubits according to a strategy set\n    using ``entanglement``. Both the rotation and entanglement gates can be specified as\n    string (e.g. ``'ry'`` or ``'cx'``), as gate-type (e.g. ``RYGate`` or ``CXGate``) or\n    as QuantumCircuit (e.g. a 1-qubit circuit or 2-qubit circuit).\n\n    A set of default entanglement strategies is provided:\n\n    * ``'full'`` entanglement is each qubit is entangled with all the others.\n    * ``'linear'`` entanglement is qubit :math:`i` entangled with qubit :math:`i + 1`,\n      for all :math:`i \\in \\{0, 1, ... , n - 2\\}`, where :math:`n` is the total number of qubits.\n    * ``'reverse_linear'`` entanglement is qubit :math:`i` entangled with qubit :math:`i + 1`,\n      for all :math:`i \\in \\{n-2, n-3, ... , 1, 0\\}`, where :math:`n` is the total number of qubits.\n      Note that if ``entanglement_blocks = 'cx'`` then this option provides the same unitary as\n      ``'full'`` with fewer entangling gates.\n    * ``'pairwise'`` entanglement is one layer where qubit :math:`i` is entangled with qubit\n      :math:`i + 1`, for all even values of :math:`i`, and then a second layer where qubit :math:`i`\n      is entangled with qubit :math:`i + 1`, for all odd values of :math:`i`.\n    * ``'circular'`` entanglement is linear entanglement but with an additional entanglement of the\n      first and last qubit before the linear part.\n    * ``'sca'`` (shifted-circular-alternating) entanglement is a generalized and modified version\n      of the proposed circuit 14 in `Sim et al. <https://arxiv.org/abs/1905.10876>`__.\n      It consists of circular entanglement where the 'long' entanglement connecting the first with\n      the last qubit is shifted by one each block.  Furthermore the role of control and target\n      qubits are swapped every block (therefore alternating).\n\n    The entanglement can further be specified using an entangler map, which is a list of index\n    pairs, such as\n\n    >>> entangler_map = [(0, 1), (1, 2), (2, 0)]\n\n    If different entanglements per block should be used, provide a list of entangler maps.\n    See the examples below on how this can be used.\n\n    >>> entanglement = [entangler_map_layer_1, entangler_map_layer_2, ... ]\n\n    Barriers can be inserted in between the different layers for better visualization using the\n    ``insert_barriers`` attribute.\n\n    For each parameterized gate a new parameter is generated using a\n    :class:`~qiskit.circuit.library.ParameterVector`. The name of these parameters can be chosen\n    using the ``parameter_prefix``.\n\n    Examples:\n\n        >>> two = TwoLocal(3, 'ry', 'cx', 'linear', reps=2, insert_barriers=True)\n        >>> print(two.decompose())  # decompose the layers into standard gates\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591            \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591            \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 Ry(\u03b8[0]) \u251c\u2500\u2591\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Ry(\u03b8[3]) \u251c\u2500\u2591\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Ry(\u03b8[6]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u250c\u2500\u2534\u2500\u2510      \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u250c\u2500\u2534\u2500\u2510      \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_1: \u2524 Ry(\u03b8[1]) \u251c\u2500\u2591\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2591\u2500\u2524 Ry(\u03b8[4]) \u251c\u2500\u2591\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2591\u2500\u2524 Ry(\u03b8[7]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_2: \u2524 Ry(\u03b8[2]) \u251c\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2591\u2500\u2524 Ry(\u03b8[5]) \u251c\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2591\u2500\u2524 Ry(\u03b8[8]) \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591      \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591      \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> two = TwoLocal(3, ['ry','rz'], 'cz', 'full', reps=1, insert_barriers=True, flatten=True)\n        >>> qc = QuantumCircuit(3)\n        >>> qc &= two\n        >>> print(qc.draw())\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591           \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 Ry(\u03b8[0]) \u251c\u2524 Rz(\u03b8[3]) \u251c\u2500\u2591\u2500\u2500\u25a0\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 Ry(\u03b8[6]) \u251c\u2500\u2524 Rz(\u03b8[9]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591  \u2502  \u2502     \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u250c\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_1: \u2524 Ry(\u03b8[1]) \u251c\u2524 Rz(\u03b8[4]) \u251c\u2500\u2591\u2500\u2500\u25a0\u2500\u2500\u253c\u2500\u2500\u25a0\u2500\u2500\u2591\u2500\u2524 Ry(\u03b8[7]) \u251c\u2524 Rz(\u03b8[10]) \u251c\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591     \u2502  \u2502  \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_2: \u2524 Ry(\u03b8[2]) \u251c\u2524 Rz(\u03b8[5]) \u251c\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u25a0\u2500\u2500\u2591\u2500\u2524 Ry(\u03b8[8]) \u251c\u2524 Rz(\u03b8[11]) \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591           \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> entangler_map = [[0, 1], [1, 2], [2, 0]]  # circular entanglement for 3 qubits\n        >>> two = TwoLocal(3, 'x', 'crx', entangler_map, reps=1, flatten=True)\n        >>> print(two)  # note: no barriers inserted this time!\n                \u250c\u2500\u2500\u2500\u2510                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\n        q_0: |0>\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Rx(\u03b8[2]) \u251c\u2524 X \u251c\n                \u251c\u2500\u2500\u2500\u2524\u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2510\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\n        q_1: |0>\u2524 X \u251c\u2524 Rx(\u03b8[0]) \u251c\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                \u251c\u2500\u2500\u2500\u2524\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2500\u2500\u2500\u2518      \u2502     \u250c\u2500\u2500\u2500\u2510\n        q_2: |0>\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Rx(\u03b8[1]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\n                \u2514\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2514\u2500\u2500\u2500\u2518\n\n        >>> entangler_map = [[0, 3], [0, 2]]  # entangle the first and last two-way\n        >>> two = TwoLocal(4, [], 'cry', entangler_map, reps=1, flatten=True)\n        >>> circuit = two.compose(two)\n        >>> print(circuit.draw())  # note, that the parameters are the same!\n        q_0: \u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\n                  \u2502           \u2502           \u2502           \u2502\n        q_1: \u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\n                  \u2502      \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510     \u2502      \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\n        q_2: \u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Ry(\u03b8[1]) \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Ry(\u03b8[1]) \u251c\n             \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        q_3: \u2524 Ry(\u03b8[0]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Ry(\u03b8[0]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> layer_1 = [(0, 1), (0, 2)]\n        >>> layer_2 = [(1, 2)]\n        >>> two = TwoLocal(3, 'x', 'cx', [layer_1, layer_2], reps=2, insert_barriers=True,\n        ... flatten=True)\n        >>> print(two)\n             \u250c\u2500\u2500\u2500\u2510 \u2591            \u2591 \u250c\u2500\u2500\u2500\u2510 \u2591       \u2591 \u250c\u2500\u2500\u2500\u2510\n        q_0: \u2524 X \u251c\u2500\u2591\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2591\u2500\u2524 X \u251c\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 X \u251c\n             \u251c\u2500\u2500\u2500\u2524 \u2591 \u250c\u2500\u2534\u2500\u2510  \u2502   \u2591 \u251c\u2500\u2500\u2500\u2524 \u2591       \u2591 \u251c\u2500\u2500\u2500\u2524\n        q_1: \u2524 X \u251c\u2500\u2591\u2500\u2524 X \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2591\u2500\u2524 X \u251c\u2500\u2591\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2591\u2500\u2524 X \u251c\n             \u251c\u2500\u2500\u2500\u2524 \u2591 \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510 \u2591 \u251c\u2500\u2500\u2500\u2524 \u2591 \u250c\u2500\u2534\u2500\u2510 \u2591 \u251c\u2500\u2500\u2500\u2524\n        q_2: \u2524 X \u251c\u2500\u2591\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2591\u2500\u2524 X \u251c\u2500\u2591\u2500\u2524 X \u251c\u2500\u2591\u2500\u2524 X \u251c\n             \u2514\u2500\u2500\u2500\u2518 \u2591      \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2518\n\n    ",
    "parameters": {
      "num_qubits": {
        "default": null,
        "annotation": "int | None"
      },
      "rotation_blocks": {
        "default": null,
        "annotation": "str | type | qiskit.circuit.Instruction | QuantumCircuit | list[str | type | qiskit.circuit.Instruction | QuantumCircuit] | None"
      },
      "entanglement_blocks": {
        "default": null,
        "annotation": "str | type | qiskit.circuit.Instruction | QuantumCircuit | list[str | type | qiskit.circuit.Instruction | QuantumCircuit] | None"
      },
      "entanglement": {
        "default": "full",
        "annotation": "str | list[list[int]] | Callable[[int], list[int]]"
      },
      "reps": {
        "default": 3,
        "annotation": "int"
      },
      "skip_unentangled_qubits": {
        "default": false,
        "annotation": "bool"
      },
      "skip_final_rotation_layer": {
        "default": false,
        "annotation": "bool"
      },
      "parameter_prefix": {
        "default": "\u03b8",
        "annotation": "str"
      },
      "insert_barriers": {
        "default": false,
        "annotation": "bool"
      },
      "initial_state": {
        "default": null,
        "annotation": "QuantumCircuit | None"
      },
      "name": {
        "default": "TwoLocal",
        "annotation": "str"
      },
      "flatten": {
        "default": null,
        "annotation": "bool | None"
      }
    }
  },
  {
    "class_name": "QuantumVolume",
    "module": "qiskit.circuit.library.quantum_volume",
    "doc": "A quantum volume model circuit.\n\n    The model circuits are random instances of circuits used to measure\n    the Quantum Volume metric, as introduced in [1].\n\n    The model circuits consist of layers of Haar random\n    elements of SU(4) applied between corresponding pairs\n    of qubits in a random bipartition.\n\n    Reference Circuit:\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import QuantumVolume\n       circuit = QuantumVolume(5, 6, seed=10)\n       circuit.draw('mpl')\n\n    Expanded Circuit:\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import QuantumVolume\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       circuit = QuantumVolume(5, 6, seed=10, classical_permutation=False)\n       _generate_circuit_library_visualization(circuit.decompose())\n\n    References:\n\n    [1] A. Cross et al. Validating quantum computers using\n    randomized model circuits, Phys. Rev. A 100, 032328 (2019).\n    `arXiv:1811.12926 <https://arxiv.org/abs/1811.12926>`__\n    ",
    "parameters": {
      "num_qubits": {
        "default": null,
        "annotation": "int"
      },
      "depth": {
        "default": null,
        "annotation": "Optional[int]"
      },
      "seed": {
        "default": null,
        "annotation": "Optional[Union[int, np.random.Generator]]"
      },
      "classical_permutation": {
        "default": true,
        "annotation": "bool"
      },
      "flatten": {
        "default": false,
        "annotation": "bool"
      }
    }
  }
]