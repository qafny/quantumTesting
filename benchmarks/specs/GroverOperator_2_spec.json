{
  "circuit_name": "GroverOperator_2",
  "class_name": "GroverOperator",
  "module": "qiskit.circuit.library.grover_operator",
  "description": "The Grover operator.\n\n    Grover's search algorithm [1, 2] consists of repeated applications of the so-called\n    Grover operator used to amplify the amplitudes of the desired output states.\n    This operator, :math:`\\mathcal{Q}`, consists of the phase oracle, :math:`\\mathcal{S}_f`,\n    zero phase-shift or zero reflection, :math:`\\mathcal{S}_0`, and an\n    input state preparation :math:`\\mathcal{A}`:\n\n    .. math::\n        \\mathcal{Q} = \\mathcal{A} \\mathcal{S}_0 \\mathcal{A}^\\dagger \\mathcal{S}_f\n\n    In the standard Grover search we have :math:`\\mathcal{A} = H^{\\otimes n}`:\n\n    .. math::\n        \\mathcal{Q} = H^{\\otimes n} \\mathcal{S}_0 H^{\\otimes n} \\mathcal{S}_f\n                    = D \\mathcal{S_f}\n\n    The operation :math:`D = H^{\\otimes n} \\mathcal{S}_0 H^{\\otimes n}` is also referred to as\n    diffusion operator. In this formulation we can see that Grover's operator consists of two\n    steps: first, the phase oracle multiplies the good states by -1 (with :math:`\\mathcal{S}_f`)\n    and then the whole state is reflected around the mean (with :math:`D`).\n\n    This class allows setting a different state preparation, as in quantum amplitude\n    amplification (a generalization of Grover's algorithm), :math:`\\mathcal{A}` might not be\n    a layer of Hardamard gates [3].\n\n    The action of the phase oracle :math:`\\mathcal{S}_f` is defined as\n\n    .. math::\n        \\mathcal{S}_f: |x\\rangle \\mapsto (-1)^{f(x)}|x\\rangle\n\n    where :math:`f(x) = 1` if :math:`x` is a good state and 0 otherwise. To highlight the fact\n    that this oracle flips the phase of the good states and does not flip the state of a result\n    qubit, we call :math:`\\mathcal{S}_f` a phase oracle.\n\n    Note that you can easily construct a phase oracle from a bitflip oracle by sandwiching the\n    controlled X gate on the result qubit by a X and H gate. For instance\n\n    .. code-block:: text\n\n        Bitflip oracle     Phaseflip oracle\n        q_0: \u2500\u2500\u25a0\u2500\u2500         q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u250c\u2500\u2534\u2500\u2510              \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\n        out: \u2524 X \u251c         out: \u2524 X \u251c\u2524 H \u251c\u2524 X \u251c\u2524 H \u251c\u2524 X \u251c\n             \u2514\u2500\u2500\u2500\u2518              \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\n\n    There is some flexibility in defining the oracle and :math:`\\mathcal{A}` operator. Before the\n    Grover operator is applied in Grover's algorithm, the qubits are first prepared with one\n    application of the :math:`\\mathcal{A}` operator (or Hadamard gates in the standard formulation).\n    Thus, we always have operation of the form\n    :math:`\\mathcal{A} \\mathcal{S}_f \\mathcal{A}^\\dagger`. Therefore it is possible to move\n    bitflip logic into :math:`\\mathcal{A}` and leaving the oracle only to do phaseflips via Z gates\n    based on the bitflips. One possible use-case for this are oracles that do not uncompute the\n    state qubits.\n\n    The zero reflection :math:`\\mathcal{S}_0` is usually defined as\n\n    .. math::\n        \\mathcal{S}_0 = 2 |0\\rangle^{\\otimes n} \\langle 0|^{\\otimes n} - \\mathbb{I}_n\n\n    where :math:`\\mathbb{I}_n` is the identity on :math:`n` qubits.\n    By default, this class implements the negative version\n    :math:`2 |0\\rangle^{\\otimes n} \\langle 0|^{\\otimes n} - \\mathbb{I}_n`, since this can simply\n    be implemented with a multi-controlled Z sandwiched by X gates on the target qubit and the\n    introduced global phase does not matter for Grover's algorithm.\n\n    Examples:\n        >>> from qiskit.circuit import QuantumCircuit\n        >>> from qiskit.circuit.library import GroverOperator\n        >>> oracle = QuantumCircuit(2)\n        >>> oracle.z(0)  # good state = first qubit is |1>\n        >>> grover_op = GroverOperator(oracle, insert_barriers=True)\n        >>> grover_op.decompose().draw()\n                 \u250c\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2510      \u2591 \u250c\u2500\u2500\u2500\u2510\n        state_0: \u2524 Z \u251c\u2500\u2591\u2500\u2524 H \u251c\u2500\u2591\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 H \u251c\n                 \u2514\u2500\u2500\u2500\u2518 \u2591 \u251c\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2524\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u251c\u2500\u2500\u2500\u2524\u250c\u2500\u2500\u2500\u2510 \u2591 \u251c\u2500\u2500\u2500\u2524\n        state_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u2524 H \u251c\u2500\u2591\u2500\u2524 X \u251c\u2524 H \u251c\u2524 X \u251c\u2524 H \u251c\u2524 X \u251c\u2500\u2591\u2500\u2524 H \u251c\n                       \u2591 \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2518\n\n        >>> oracle = QuantumCircuit(1)\n        >>> oracle.z(0)  # the qubit state |1> is the good state\n        >>> state_preparation = QuantumCircuit(1)\n        >>> state_preparation.ry(0.2, 0)  # non-uniform state preparation\n        >>> grover_op = GroverOperator(oracle, state_preparation)\n        >>> grover_op.decompose().draw()\n                 \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        state_0: \u2524 Z \u251c\u2524 RY(-0.2) \u251c\u2524 X \u251c\u2524 Z \u251c\u2524 X \u251c\u2524 RY(0.2) \u251c\n                 \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> oracle = QuantumCircuit(4)\n        >>> oracle.z(3)\n        >>> reflection_qubits = [0, 3]\n        >>> state_preparation = QuantumCircuit(4)\n        >>> state_preparation.cry(0.1, 0, 3)\n        >>> state_preparation.ry(0.5, 3)\n        >>> grover_op = GroverOperator(oracle, state_preparation,\n        ... reflection_qubits=reflection_qubits)\n        >>> grover_op.decompose().draw()\n                                              \u250c\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2510\n        state_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                                       \u2502      \u2514\u2500\u2500\u2500\u2518       \u2502  \u2514\u2500\u2500\u2500\u2518          \u2502\n        state_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                                       \u2502                  \u2502                 \u2502\n        state_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                 \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        state_3: \u2524 Z \u251c\u2524 RY(-0.5) \u251c\u2524 RY(-0.1) \u251c\u2524 X \u251c\u2524 H \u251c\u2524 X \u251c\u2524 H \u251c\u2524 X \u251c\u2524 RY(0.1) \u251c\u2524 RY(0.5) \u251c\n                 \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> mark_state = Statevector.from_label('011')\n        >>> diffuse_operator = 2 * DensityMatrix.from_label('000') - Operator.from_label('III')\n        >>> grover_op = GroverOperator(oracle=mark_state, zero_reflection=diffuse_operator)\n        >>> grover_op.decompose().draw(fold=70)\n                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2510                          \u00bb\n        state_0: \u25240                \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\n                 \u2502                 \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2510          \u00bb\n        state_1: \u25241 UCRZ(0,pi,0,0) \u251c\u25240              \u251c\u2500\u2500\u2500\u2500\u2500\u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u00bb\n                 \u2502                 \u2502\u2502  UCRZ(pi/2,0) \u2502\u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u00bb\n        state_2: \u25242                \u251c\u25241              \u251c\u2524 UCRZ(-pi/4) \u251c\u2524 H \u251c\u00bb\n                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u00bb\n        \u00ab         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2510\n        \u00abstate_0: \u25240                \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        \u00ab         \u2502                 \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2510\n        \u00abstate_1: \u25241 UCRZ(pi,0,0,0) \u251c\u25240              \u251c\u2500\u2500\u2500\u2500\u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        \u00ab         \u2502                 \u2502\u2502  UCRZ(pi/2,0) \u2502\u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\n        \u00abstate_2: \u25242                \u251c\u25241              \u251c\u2524 UCRZ(pi/4) \u251c\u2524 H \u251c\n        \u00ab         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\n\n    .. seealso::\n\n        The :func:`.grover_operator` implements the same functionality but keeping the\n        :class:`.MCXGate` abstract, such that the compiler may choose the optimal decomposition.\n        We recommend using :func:`.grover_operator` for performance reasons, which does not\n        wrap the circuit into an opaque gate.\n\n    References:\n\n    [1] L. K. Grover (1996), A fast quantum mechanical algorithm for database search,\n    `arXiv:quant-ph/9605043 <https://arxiv.org/abs/quant-ph/9605043>`_.\n\n    [2] I. Chuang & M. Nielsen, Quantum Computation and Quantum Information,\n    Cambridge: Cambridge University Press, 2000. Chapter 6.1.2.\n\n    [3] Brassard, G., Hoyer, P., Mosca, M., & Tapp, A. (2000).\n    Quantum Amplitude Amplification and Estimation.\n    `arXiv:quant-ph/0005055 <http://arxiv.org/abs/quant-ph/0005055>`_.\n    ",
  "num_qubits": 2,
  "num_clbits": 0,
  "specification": "\nCircuit: GroverOperator_2\nQubits: 2\nClassical bits: 0\nDepth: 1\nSize: 1\n\nExpected Behavior:\n- Circuit should compile to XMLProgrammer AST without errors\n- AST should be valid according to SimulatorValidator\n- Simulator should execute without runtime errors\n- Output state should be consistent with circuit semantics\n",
  "expected_behavior": "Implements Grover search operator"
}